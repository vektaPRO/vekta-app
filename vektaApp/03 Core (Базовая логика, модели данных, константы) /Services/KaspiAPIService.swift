//
//  KaspiAPIService.swift
//  vektaApp
//
//  ÐŸÐ¾Ð»Ð½Ð°Ñ Ð¸Ð½Ñ‚ÐµÐ³Ñ€Ð°Ñ†Ð¸Ñ Ñ Kaspi API
//

import Foundation
import FirebaseAuth
import FirebaseFirestore

// MARK: - Kaspi API Models

/// ÐœÐ¾Ð´ÐµÐ»ÑŒ Ñ‚Ð¾Ð²Ð°Ñ€Ð° Ð¸Ð· Kaspi API
struct KaspiProductResponse: Codable {
    let id: String
    let sku: String
    let name: String
    let description: String?
    let price: Double
    let category: String
    let images: [String]
    let stock: KaspiStock
    let isActive: Bool
    
    enum CodingKeys: String, CodingKey {
        case id = "product_id"
        case sku
        case name
        case description
        case price
        case category
        case images
        case stock
        case isActive = "is_active"
    }
}

/// ÐžÑÑ‚Ð°Ñ‚ÐºÐ¸ Ñ‚Ð¾Ð²Ð°Ñ€Ð° Ð¿Ð¾ ÑÐºÐ»Ð°Ð´Ð°Ð¼
struct KaspiStock: Codable {
    let total: Int
    let warehouses: [KaspiWarehouseStock]
}

/// ÐžÑÑ‚Ð°Ñ‚ÐºÐ¸ Ð½Ð° ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ð¾Ð¼ ÑÐºÐ»Ð°Ð´Ðµ
struct KaspiWarehouseStock: Codable {
    let warehouseId: String
    let warehouseName: String
    let quantity: Int
    let reserved: Int
    let available: Int
    
    enum CodingKeys: String, CodingKey {
        case warehouseId = "warehouse_id"
        case warehouseName = "warehouse_name"
        case quantity
        case reserved
        case available
    }
}

/// ÐžÑ‚Ð²ÐµÑ‚ Ð½Ð° Ð·Ð°Ð¿Ñ€Ð¾Ñ SMS ÐºÐ¾Ð´Ð°
struct KaspiSMSCodeRequest: Codable {
    let orderId: String
    let trackingNumber: String
    let customerPhone: String
    
    enum CodingKeys: String, CodingKey {
        case orderId = "order_id"
        case trackingNumber = "tracking_number"
        case customerPhone = "customer_phone"
    }
}

/// ÐŸÐ¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ðµ Ð´Ð¾ÑÑ‚Ð°Ð²ÐºÐ¸
struct KaspiDeliveryConfirmation: Codable {
    let orderId: String
    let trackingNumber: String
    let confirmationCode: String
    let confirmedAt: Date?
    
    enum CodingKeys: String, CodingKey {
        case orderId = "order_id"
        case trackingNumber = "tracking_number"
        case confirmationCode = "confirmation_code"
        case confirmedAt = "confirmed_at"
    }
}

// MARK: - Errors

enum KaspiAPIError: LocalizedError {
    case tokenNotFound
    case invalidToken
    case networkError(String)
    case authenticationFailed
    case rateLimitExceeded
    case invalidResponse
    case syncFailed(String)
    case smsCodeError(String)
    
    var errorDescription: String? {
        switch self {
        case .tokenNotFound:
            return "API Ñ‚Ð¾ÐºÐµÐ½ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½. ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð´Ð¾Ð±Ð°Ð²ÑŒÑ‚Ðµ Ñ‚Ð¾ÐºÐµÐ½ Ð² Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ°Ñ…."
        case .invalidToken:
            return "ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ API Ñ‚Ð¾ÐºÐµÐ½. ÐŸÑ€Ð¾Ð²ÐµÑ€ÑŒÑ‚Ðµ Ð¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¾ÑÑ‚ÑŒ Ñ‚Ð¾ÐºÐµÐ½Ð°."
        case .networkError(let message):
            return "ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐµÑ‚Ð¸: \(message)"
        case .authenticationFailed:
            return "ÐžÑˆÐ¸Ð±ÐºÐ° Ð°ÑƒÑ‚ÐµÐ½Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ†Ð¸Ð¸. ÐŸÑ€Ð¾Ð²ÐµÑ€ÑŒÑ‚Ðµ Ð²Ð°Ñˆ API Ñ‚Ð¾ÐºÐµÐ½."
        case .rateLimitExceeded:
            return "ÐŸÑ€ÐµÐ²Ñ‹ÑˆÐµÐ½ Ð»Ð¸Ð¼Ð¸Ñ‚ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ¾Ð². ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð¿Ð¾Ð·Ð¶Ðµ."
        case .invalidResponse:
            return "ÐÐµÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ñ‹Ð¹ Ð¾Ñ‚Ð²ÐµÑ‚ Ð¾Ñ‚ ÑÐµÑ€Ð²ÐµÑ€Ð°"
        case .syncFailed(let message):
            return "ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð¸Ð·Ð°Ñ†Ð¸Ð¸: \(message)"
        case .smsCodeError(let message):
            return "ÐžÑˆÐ¸Ð±ÐºÐ° Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¸ SMS ÐºÐ¾Ð´Ð°: \(message)"
        }
    }
}

// MARK: - KaspiAPIService

@MainActor
class KaspiAPIService: ObservableObject {
    
    // MARK: - Published Properties
    
    @Published var isLoading = false
    @Published var errorMessage: String?
    @Published var lastSyncDate: Date?
    @Published var apiToken: String?
    @Published var syncProgress: Double = 0.0
    
    // MARK: - Private Properties
    
    private let db = Firestore.firestore()
    private var authListener: AuthStateDidChangeListenerHandle?
    private let baseURL = "https://kaspi.kz/merchantcabinet/api/v1"
    private let session = URLSession.shared
    
    // MARK: - Initialization
    
    init() {
        print("ðŸ”§ KaspiAPIService Ð¸Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ð½")
        setupAuthListener()
    }
    
    deinit {
        if let listener = authListener {
            Auth.auth().removeStateDidChangeListener(listener)
        }
    }
    
    // MARK: - Authentication
    
    private func setupAuthListener() {
        authListener = Auth.auth().addStateDidChangeListener { [weak self] _, user in
            Task { @MainActor in
                if user != nil {
                    await self?.loadApiToken()
                } else {
                    self?.apiToken = nil
                }
            }
        }
    }
    
    func loadApiToken() async {
        guard let userId = Auth.auth().currentUser?.uid else {
            print("âŒ ÐÐµÑ‚ Ð°Ð²Ñ‚Ð¾Ñ€Ð¸Ð·Ð¾Ð²Ð°Ð½Ð½Ð¾Ð³Ð¾ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ")
            errorMessage = "ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ Ð½Ðµ Ð°Ð²Ñ‚Ð¾Ñ€Ð¸Ð·Ð¾Ð²Ð°Ð½"
            return
        }
        
        print("ðŸ” Ð—Ð°Ð³Ñ€ÑƒÐ¶Ð°ÐµÐ¼ Ñ‚Ð¾ÐºÐµÐ½ Ð´Ð»Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ: \(userId)")
        
        do {
            let document = try await db.collection("sellers").document(userId).getDocument()
            
            if let data = document.data(),
               let token = data["kaspiApiToken"] as? String {
                apiToken = token
                errorMessage = nil
                print("âœ… Kaspi API Ñ‚Ð¾ÐºÐµÐ½ Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½")
            } else {
                print("âš ï¸ Kaspi API Ñ‚Ð¾ÐºÐµÐ½ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½")
                apiToken = nil
                errorMessage = "Ð¢Ð¾ÐºÐµÐ½ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½. Ð”Ð¾Ð±Ð°Ð²ÑŒÑ‚Ðµ Ñ‚Ð¾ÐºÐµÐ½ Ð² Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ°Ñ…."
            }
        } catch {
            print("âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸ Ñ‚Ð¾ÐºÐµÐ½Ð°: \(error.localizedDescription)")
            errorMessage = "ÐžÑˆÐ¸Ð±ÐºÐ° Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸ Ñ‚Ð¾ÐºÐµÐ½Ð°"
        }
    }
    
    func loadApiToken() {
        Task {
            await loadApiToken()
        }
    }
    
    // MARK: - API Methods
    
    /// ÐŸÑ€Ð¾Ð²ÐµÑ€Ð¸Ñ‚ÑŒ Ð²Ð°Ð»Ð¸Ð´Ð½Ð¾ÑÑ‚ÑŒ Ñ‚Ð¾ÐºÐµÐ½Ð°
    func validateToken() async throws -> Bool {
        guard let token = apiToken else {
            throw KaspiAPIError.tokenNotFound
        }
        
        // Ð”Ð»Ñ Ð´ÐµÐ¼Ð¾Ð½ÑÑ‚Ñ€Ð°Ñ†Ð¸Ð¸ - Ð¸Ð¼Ð¸Ñ‚Ð¸Ñ€ÑƒÐµÐ¼ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÑƒ Ñ‚Ð¾ÐºÐµÐ½Ð°
        // Ð’ Ñ€ÐµÐ°Ð»ÑŒÐ½Ð¾Ð¼ Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¸ Ð·Ð´ÐµÑÑŒ Ð±ÑƒÐ´ÐµÑ‚ Ð·Ð°Ð¿Ñ€Ð¾Ñ Ðº Kaspi API
        
        try await Task.sleep(nanoseconds: 1_000_000_000) // 1 ÑÐµÐºÑƒÐ½Ð´Ð°
        
        // ÐŸÑ€Ð¾ÑÑ‚Ð°Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ° Ñ‚Ð¾ÐºÐµÐ½Ð°
        if token.count > 10 && !token.isEmpty {
            return true
        } else {
            throw KaspiAPIError.invalidToken
        }
    }
    
    /// Ð¡Ð¸Ð½Ñ…Ñ€Ð¾Ð½Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð²ÑÐµ Ñ‚Ð¾Ð²Ð°Ñ€Ñ‹
    func syncAllProducts() async throws -> [Product] {
        guard let token = apiToken else {
            throw KaspiAPIError.tokenNotFound
        }
        
        isLoading = true
        errorMessage = nil
        syncProgress = 0.0
        
        do {
            // Ð’Ð°Ð»Ð¸Ð´Ð¸Ñ€ÑƒÐµÐ¼ Ñ‚Ð¾ÐºÐµÐ½
            let isValid = try await validateToken()
            guard isValid else {
                throw KaspiAPIError.invalidToken
            }
            
            // Ð˜Ð¼Ð¸Ñ‚Ð¸Ñ€ÑƒÐµÐ¼ Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÑƒ Ñ‚Ð¾Ð²Ð°Ñ€Ð¾Ð² Ð¸Ð· Kaspi API
            // Ð’ Ñ€ÐµÐ°Ð»ÑŒÐ½Ð¾Ð¼ Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¸ Ð·Ð´ÐµÑÑŒ Ð±ÑƒÐ´ÐµÑ‚ Ð·Ð°Ð¿Ñ€Ð¾Ñ Ðº API
            let products = try await simulateProductSync()
            
            // Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ Ð² Firestore
            try await saveProductsToFirestore(products)
            
            isLoading = false
            lastSyncDate = Date()
            syncProgress = 1.0
            print("âœ… Ð¡Ð¸Ð½Ñ…Ñ€Ð¾Ð½Ð¸Ð·Ð°Ñ†Ð¸Ñ Ð·Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ð°! Ð—Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ð¾ \(products.count) Ñ‚Ð¾Ð²Ð°Ñ€Ð¾Ð²")
            
            return products
            
        } catch {
            isLoading = false
            errorMessage = error.localizedDescription
            syncProgress = 0.0
            throw error
        }
    }
    
    /// Ð˜Ð¼Ð¸Ñ‚Ð°Ñ†Ð¸Ñ ÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð¸Ð·Ð°Ñ†Ð¸Ð¸ Ñ‚Ð¾Ð²Ð°Ñ€Ð¾Ð² (Ð´Ð»Ñ Ð´ÐµÐ¼Ð¾Ð½ÑÑ‚Ñ€Ð°Ñ†Ð¸Ð¸)
    private func simulateProductSync() async throws -> [Product] {
        // Ð˜Ð¼Ð¸Ñ‚Ð¸Ñ€ÑƒÐµÐ¼ Ð¿Ñ€Ð¾Ñ†ÐµÑÑ ÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð¸Ð·Ð°Ñ†Ð¸Ð¸
        for i in 0...10 {
            syncProgress = Double(i) / 10.0
            try await Task.sleep(nanoseconds: 200_000_000) // 0.2 ÑÐµÐºÑƒÐ½Ð´Ñ‹
        }
        
        // Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÐ¼ Ñ‚ÐµÑÑ‚Ð¾Ð²Ñ‹Ðµ Ñ‚Ð¾Ð²Ð°Ñ€Ñ‹
        return Product.sampleProducts
    }
    
    /// Ð¡Ð¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ Ñ‚Ð¾Ð²Ð°Ñ€Ñ‹ Ð² Firestore
    private func saveProductsToFirestore(_ products: [Product]) async throws {
        guard let userId = Auth.auth().currentUser?.uid else {
            throw KaspiAPIError.authenticationFailed
        }
        
        let batch = db.batch()
        let productsRef = db.collection("sellers").document(userId).collection("products")
        
        for product in products {
            let docRef = productsRef.document(product.id)
            batch.setData(product.toDictionary(), forDocument: docRef, merge: true)
        }
        
        try await batch.commit()
    }
    
    // MARK: - SMS Code & Delivery Confirmation
    
    /// Ð—Ð°Ð¿Ñ€Ð¾ÑÐ¸Ñ‚ÑŒ SMS ÐºÐ¾Ð´ Ð´Ð»Ñ Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ñ Ð´Ð¾ÑÑ‚Ð°Ð²ÐºÐ¸
    func requestSMSCode(orderId: String, trackingNumber: String) async throws {
        guard let token = apiToken else {
            throw KaspiAPIError.tokenNotFound
        }
        
        // Ð˜Ð¼Ð¸Ñ‚Ð¸Ñ€ÑƒÐµÐ¼ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÑƒ SMS ÐºÐ¾Ð´Ð°
        try await Task.sleep(nanoseconds: 1_000_000_000) // 1 ÑÐµÐºÑƒÐ½Ð´Ð°
        
        print("âœ… SMS ÐºÐ¾Ð´ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½ ÐºÐ»Ð¸ÐµÐ½Ñ‚Ñƒ Ð´Ð»Ñ Ð·Ð°ÐºÐ°Ð·Ð° \(orderId)")
    }
    
    /// ÐŸÐ¾Ð´Ñ‚Ð²ÐµÑ€Ð´Ð¸Ñ‚ÑŒ Ð´Ð¾ÑÑ‚Ð°Ð²ÐºÑƒ Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ SMS ÐºÐ¾Ð´Ð°
    func confirmDelivery(orderId: String, trackingNumber: String, smsCode: String) async throws -> Bool {
        guard let token = apiToken else {
            throw KaspiAPIError.tokenNotFound
        }
        
        // Ð˜Ð¼Ð¸Ñ‚Ð¸Ñ€ÑƒÐµÐ¼ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÑƒ SMS ÐºÐ¾Ð´Ð°
        try await Task.sleep(nanoseconds: 500_000_000) // 0.5 ÑÐµÐºÑƒÐ½Ð´Ñ‹
        
        // Ð”Ð»Ñ Ð´ÐµÐ¼Ð¾Ð½ÑÑ‚Ñ€Ð°Ñ†Ð¸Ð¸ - ÐºÐ¾Ð´ "123456" Ð²ÑÐµÐ³Ð´Ð° Ð¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ñ‹Ð¹
        if smsCode == "123456" {
            try await saveDeliveryConfirmation(orderId: orderId, trackingNumber: trackingNumber, smsCode: smsCode)
            return true
        } else {
            throw KaspiAPIError.smsCodeError("ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ ÐºÐ¾Ð´ Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ñ")
        }
    }
    
    /// Ð¡Ð¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ðµ Ð´Ð¾ÑÑ‚Ð°Ð²ÐºÐ¸ Ð² Firestore
    private func saveDeliveryConfirmation(orderId: String, trackingNumber: String, smsCode: String) async throws {
        guard let userId = Auth.auth().currentUser?.uid else {
            throw KaspiAPIError.authenticationFailed
        }
        
        let confirmationData: [String: Any] = [
            "orderId": orderId,
            "trackingNumber": trackingNumber,
            "confirmationCode": smsCode,
            "confirmedAt": FieldValue.serverTimestamp(),
            "confirmedBy": userId
        ]
        
        try await db.collection("deliveryConfirmations").document(orderId).setData(confirmationData)
    }
    
    // MARK: - Stock Management
    
    /// ÐžÐ±Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ Ð¾ÑÑ‚Ð°Ñ‚ÐºÐ¸ Ñ‚Ð¾Ð²Ð°Ñ€Ð°
    func updateStock(productId: String, warehouseId: String, quantity: Int) async throws {
        guard let token = apiToken else {
            throw KaspiAPIError.tokenNotFound
        }
        
        // Ð˜Ð¼Ð¸Ñ‚Ð¸Ñ€ÑƒÐµÐ¼ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ Ð¾ÑÑ‚Ð°Ñ‚ÐºÐ¾Ð²
        try await Task.sleep(nanoseconds: 500_000_000) // 0.5 ÑÐµÐºÑƒÐ½Ð´Ñ‹
        
        print("âœ… ÐžÑÑ‚Ð°Ñ‚ÐºÐ¸ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ñ‹ Ð´Ð»Ñ Ñ‚Ð¾Ð²Ð°Ñ€Ð° \(productId)")
    }
    
    // MARK: - Utility Methods
    
    func checkAPIHealth() async -> Bool {
        do {
            return try await validateToken()
        } catch {
            return false
        }
    }
    
    var apiStatistics: (requests: Int, lastSync: Date?) {
        return (0, lastSyncDate)
    }
}
