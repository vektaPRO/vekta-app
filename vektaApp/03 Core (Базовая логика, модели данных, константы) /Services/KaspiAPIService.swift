//
//  KaspiAPIService.swift
//  vektaApp
//
//  –ü–æ–ª–Ω–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Kaspi API
//

import Foundation
import FirebaseAuth
import FirebaseFirestore

// MARK: - Kaspi API Models

/// –ú–æ–¥–µ–ª—å —Ç–æ–≤–∞—Ä–∞ –∏–∑ Kaspi API
struct KaspiProductResponse: Codable {
    let id: String
    let sku: String
    let name: String
    let description: String?
    let price: Double
    let category: String
    let images: [String]
    let stock: KaspiStock
    let isActive: Bool
    
    enum CodingKeys: String, CodingKey {
        case id = "product_id"
        case sku
        case name
        case description
        case price
        case category
        case images
        case stock
        case isActive = "is_active"
    }
}

/// –û—Å—Ç–∞—Ç–∫–∏ —Ç–æ–≤–∞—Ä–∞ –ø–æ —Å–∫–ª–∞–¥–∞–º
struct KaspiStock: Codable {
    let total: Int
    let warehouses: [KaspiWarehouseStock]
}

/// –û—Å—Ç–∞—Ç–∫–∏ –Ω–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º —Å–∫–ª–∞–¥–µ
struct KaspiWarehouseStock: Codable {
    let warehouseId: String
    let warehouseName: String
    let quantity: Int
    let reserved: Int
    let available: Int
    
    enum CodingKeys: String, CodingKey {
        case warehouseId = "warehouse_id"
        case warehouseName = "warehouse_name"
        case quantity
        case reserved
        case available
    }
}

/// –ó–∞–ø—Ä–æ—Å –Ω–∞ –æ—Ç–ø—Ä–∞–≤–∫—É SMS –∫–æ–¥–∞
struct KaspiSMSCodeRequest: Codable {
    let orderId: String
    let trackingNumber: String
    let customerPhone: String
    
    enum CodingKeys: String, CodingKey {
        case orderId = "order_id"
        case trackingNumber = "tracking_number"
        case customerPhone = "customer_phone"
    }
}

/// –û—Ç–≤–µ—Ç –Ω–∞ –∑–∞–ø—Ä–æ—Å SMS –∫–æ–¥–∞
struct KaspiSMSCodeResponse: Codable {
    let success: Bool
    let messageId: String?
    let expiresAt: Date?
    let attemptsLeft: Int
    
    enum CodingKeys: String, CodingKey {
        case success
        case messageId = "message_id"
        case expiresAt = "expires_at"
        case attemptsLeft = "attempts_left"
    }
}

/// –ó–∞–ø—Ä–æ—Å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –¥–æ—Å—Ç–∞–≤–∫–∏
struct KaspiDeliveryConfirmationRequest: Codable {
    let orderId: String
    let trackingNumber: String
    let confirmationCode: String
    
    enum CodingKeys: String, CodingKey {
        case orderId = "order_id"
        case trackingNumber = "tracking_number"
        case confirmationCode = "confirmation_code"
    }
}

/// –û—Ç–≤–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –¥–æ—Å—Ç–∞–≤–∫–∏
struct KaspiDeliveryConfirmationResponse: Codable {
    let success: Bool
    let confirmed: Bool
    let confirmedAt: Date?
    let message: String?
    
    enum CodingKeys: String, CodingKey {
        case success
        case confirmed
        case confirmedAt = "confirmed_at"
        case message
    }
}

/// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ—Å—Ç–∞—Ç–∫–æ–≤
struct KaspiStockUpdateRequest: Codable {
    let productId: String
    let warehouseId: String
    let quantity: Int
    let operation: StockOperation
    
    enum StockOperation: String, Codable {
        case set = "SET"        // –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ç–æ—á–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
        case add = "ADD"        // –î–æ–±–∞–≤–∏—Ç—å –∫ —Ç–µ–∫—É—â–µ–º—É
        case subtract = "SUBTRACT" // –í—ã—á–µ—Å—Ç—å –∏–∑ —Ç–µ–∫—É—â–µ–≥–æ
    }
    
    enum CodingKeys: String, CodingKey {
        case productId = "product_id"
        case warehouseId = "warehouse_id"
        case quantity
        case operation
    }
}

/// –û—Ç–≤–µ—Ç –æ–± –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –æ—Å—Ç–∞—Ç–∫–æ–≤
struct KaspiStockUpdateResponse: Codable {
    let success: Bool
    let productId: String
    let warehouseId: String
    let previousQuantity: Int
    let newQuantity: Int
    
    enum CodingKeys: String, CodingKey {
        case success
        case productId = "product_id"
        case warehouseId = "warehouse_id"
        case previousQuantity = "previous_quantity"
        case newQuantity = "new_quantity"
    }
}

// MARK: - Errors

enum KaspiAPIError: LocalizedError {
    case tokenNotFound
    case invalidToken
    case networkError(String)
    case authenticationFailed
    case rateLimitExceeded
    case invalidResponse
    case syncFailed(String)
    case smsCodeError(String)
    case stockUpdateError(String)
    
    var errorDescription: String? {
        switch self {
        case .tokenNotFound:
            return "API —Ç–æ–∫–µ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–±–∞–≤—å—Ç–µ —Ç–æ–∫–µ–Ω –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö."
        case .invalidToken:
            return "–ù–µ–≤–µ—Ä–Ω—ã–π API —Ç–æ–∫–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å —Ç–æ–∫–µ–Ω–∞."
        case .networkError(let message):
            return "–û—à–∏–±–∫–∞ —Å–µ—Ç–∏: \(message)"
        case .authenticationFailed:
            return "–û—à–∏–±–∫–∞ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≤–∞—à API —Ç–æ–∫–µ–Ω."
        case .rateLimitExceeded:
            return "–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
        case .invalidResponse:
            return "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –æ—Ç–≤–µ—Ç –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞"
        case .syncFailed(let message):
            return "–û—à–∏–±–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏: \(message)"
        case .smsCodeError(let message):
            return "–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ SMS –∫–æ–¥–∞: \(message)"
        case .stockUpdateError(let message):
            return "–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –æ—Å—Ç–∞—Ç–∫–æ–≤: \(message)"
        }
    }
}

// MARK: - KaspiAPIService

@MainActor
class KaspiAPIService: ObservableObject {
    
    // MARK: - Published Properties
    
    @Published var isLoading = false
    @Published var errorMessage: String?
    @Published var lastSyncDate: Date?
    @Published var apiToken: String?
    @Published var syncProgress: Double = 0.0
    
    // MARK: - Private Properties
    
    private let db = Firestore.firestore()
    private let networkManager = NetworkManager.shared
    private var authListener: AuthStateDidChangeListenerHandle?
    
    // Endpoints
    private enum Endpoints {
        static let validateToken = "/auth/validate"
        static let products = "/products"
        static let productDetail = "/products/%@"
        static let updateStock = "/stock/update"
        static let requestSMSCode = "/delivery/sms/request"
        static let confirmDelivery = "/delivery/confirm"
        static let warehouses = "/warehouses"
    }
    
    // MARK: - Initialization
    
    init() {
        print("üîß KaspiAPIService –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
        setupAuthListener()
    }
    
    deinit {
        if let listener = authListener {
            Auth.auth().removeStateDidChangeListener(listener)
        }
    }
    
    // MARK: - Authentication
    
    private func setupAuthListener() {
        authListener = Auth.auth().addStateDidChangeListener { [weak self] _, user in
            Task { @MainActor in
                if user != nil {
                    await self?.loadApiToken()
                } else {
                    self?.apiToken = nil
                }
            }
        }
    }
    
    func loadApiToken() async {
        guard let userId = Auth.auth().currentUser?.uid else {
            print("‚ùå –ù–µ—Ç –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
            errorMessage = "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω"
            return
        }
        
        print("üîç –ó–∞–≥—Ä—É–∂–∞–µ–º —Ç–æ–∫–µ–Ω –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: \(userId)")
        
        do {
            let document = try await db.collection("sellers").document(userId).getDocument()
            
            if let data = document.data(),
               let token = data["kaspiApiToken"] as? String {
                apiToken = token
                errorMessage = nil
                print("‚úÖ Kaspi API —Ç–æ–∫–µ–Ω –∑–∞–≥—Ä—É–∂–µ–Ω")
            } else {
                print("‚ö†Ô∏è Kaspi API —Ç–æ–∫–µ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω")
                apiToken = nil
                errorMessage = "–¢–æ–∫–µ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω. –î–æ–±–∞–≤—å—Ç–µ —Ç–æ–∫–µ–Ω –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö."
            }
        } catch {
            print("‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ç–æ–∫–µ–Ω–∞: \(error.localizedDescription)")
            errorMessage = "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ç–æ–∫–µ–Ω–∞"
        }
    }
    
    // MARK: - API Methods
    
    /// –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å —Ç–æ–∫–µ–Ω–∞
    func validateToken() async throws -> Bool {
        guard let token = apiToken else {
            throw KaspiAPIError.tokenNotFound
        }
        
        struct ValidateResponse: Codable {
            let valid: Bool
            let merchantId: String?
            let merchantName: String?
            
            enum CodingKeys: String, CodingKey {
                case valid
                case merchantId = "merchant_id"
                case merchantName = "merchant_name"
            }
        }
        
        do {
            let response: ValidateResponse = try await networkManager.get(
                endpoint: Endpoints.validateToken,
                apiToken: token
            )
            
            if response.valid {
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø—Ä–æ–¥–∞–≤—Ü–µ
                if let userId = Auth.auth().currentUser?.uid,
                   let merchantId = response.merchantId {
                    try await db.collection("sellers").document(userId).updateData([
                        "kaspiMerchantId": merchantId,
                        "kaspiMerchantName": response.merchantName ?? ""
                    ])
                }
            }
            
            return response.valid
            
        } catch let error as NetworkError {
            switch error {
            case .unauthorized:
                throw KaspiAPIError.invalidToken
            case .rateLimited:
                throw KaspiAPIError.rateLimitExceeded
            default:
                throw KaspiAPIError.networkError(error.localizedDescription)
            }
        } catch {
            throw KaspiAPIError.networkError(error.localizedDescription)
        }
    }
    
    /// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞—Ç—å –≤—Å–µ —Ç–æ–≤–∞—Ä—ã
    func syncAllProducts() async throws -> [Product] {
        guard let token = apiToken else {
            throw KaspiAPIError.tokenNotFound
        }
        
        isLoading = true
        errorMessage = nil
        syncProgress = 0.0
        
        do {
            // –í–∞–ª–∏–¥–∏—Ä—É–µ–º —Ç–æ–∫–µ–Ω
            let isValid = try await validateToken()
            guard isValid else {
                throw KaspiAPIError.invalidToken
            }
            
            syncProgress = 0.1
            
            // –ó–∞–≥—Ä—É–∂–∞–µ–º —Ç–æ–≤–∞—Ä—ã –ø–æ—Å—Ç—Ä–∞–Ω–∏—á–Ω–æ
            var allProducts: [Product] = []
            var currentPage = 1
            var hasMorePages = true
            
            while hasMorePages {
                let response: KaspiResponse<[KaspiProductResponse]> = try await networkManager.get(
                    endpoint: Endpoints.products,
                    parameters: [
                        "page": currentPage,
                        "page_size": 100
                    ],
                    apiToken: token
                )
                
                if let kaspiProducts = response.data {
                    // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º Kaspi —Ç–æ–≤–∞—Ä—ã –≤ –Ω–∞—à —Ñ–æ—Ä–º–∞—Ç
                    let products = kaspiProducts.compactMap { convertKaspiProductToProduct($0) }
                    allProducts.append(contentsOf: products)
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
                    if let pagination = response.pagination {
                        syncProgress = Double(currentPage) / Double(pagination.totalPages)
                        hasMorePages = currentPage < pagination.totalPages
                        currentPage += 1
                    } else {
                        hasMorePages = false
                    }
                }
            }
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ Firestore
            try await saveProductsToFirestore(allProducts)
            
            isLoading = false
            lastSyncDate = Date()
            syncProgress = 1.0
            print("‚úÖ –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞! –ó–∞–≥—Ä—É–∂–µ–Ω–æ \(allProducts.count) —Ç–æ–≤–∞—Ä–æ–≤")
            
            return allProducts
            
        } catch {
            isLoading = false
            errorMessage = error.localizedDescription
            syncProgress = 0.0
            throw error
        }
    }
    
    /// –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è —Ç–æ–≤–∞—Ä–∞ –∏–∑ —Ñ–æ—Ä–º–∞—Ç–∞ Kaspi –≤ –Ω–∞—à —Ñ–æ—Ä–º–∞—Ç
    private func convertKaspiProductToProduct(_ kaspiProduct: KaspiProductResponse) -> Product {
        // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —Å–∫–ª–∞–¥—ã
        var warehouseStock: [String: Int] = [:]
        for warehouse in kaspiProduct.stock.warehouses {
            warehouseStock[warehouse.warehouseId] = warehouse.available
        }
        
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç–∞—Ç—É—Å
        let status: ProductStatus = kaspiProduct.isActive ?
            (kaspiProduct.stock.total > 0 ? .inStock : .outOfStock) : .inactive
        
        return Product(
            id: kaspiProduct.id,
            kaspiProductId: kaspiProduct.id,
            name: kaspiProduct.name,
            description: kaspiProduct.description ?? "",
            price: kaspiProduct.price,
            category: kaspiProduct.category,
            imageURL: kaspiProduct.images.first ?? "",
            status: status,
            warehouseStock: warehouseStock,
            createdAt: Date(),
            updatedAt: Date(),
            isActive: kaspiProduct.isActive
        )
    }
    
    /// –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç–æ–≤–∞—Ä—ã –≤ Firestore
    private func saveProductsToFirestore(_ products: [Product]) async throws {
        guard let userId = Auth.auth().currentUser?.uid else {
            throw KaspiAPIError.authenticationFailed
        }
        
        let batch = db.batch()
        let productsRef = db.collection("sellers").document(userId).collection("products")
        
        // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ —Ç–æ–≤–∞—Ä—ã
        let oldProducts = try await productsRef.getDocuments()
        for doc in oldProducts.documents {
            batch.deleteDocument(doc.reference)
        }
        
        // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ —Ç–æ–≤–∞—Ä—ã
        for product in products {
            let docRef = productsRef.document(product.id)
            batch.setData(product.toDictionary(), forDocument: docRef)
        }
        
        try await batch.commit()
    }
    
    // MARK: - SMS Code & Delivery Confirmation
    
    /// –ó–∞–ø—Ä–æ—Å–∏—Ç—å SMS –∫–æ–¥ –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –¥–æ—Å—Ç–∞–≤–∫–∏
    func requestSMSCode(orderId: String, trackingNumber: String, customerPhone: String) async throws -> String {
        guard let token = apiToken else {
            throw KaspiAPIError.tokenNotFound
        }
        
        let request = KaspiSMSCodeRequest(
            orderId: orderId,
            trackingNumber: trackingNumber,
            customerPhone: customerPhone
        )
        
        do {
            let response: KaspiSMSCodeResponse = try await networkManager.post(
                endpoint: Endpoints.requestSMSCode,
                body: request,
                apiToken: token
            )
            
            if response.success {
                print("‚úÖ SMS –∫–æ–¥ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∫–ª–∏–µ–Ω—Ç—É –¥–ª—è –∑–∞–∫–∞–∑–∞ \(orderId)")
                
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∑–∞–ø—Ä–æ—Å–µ –≤ Firestore
                if let messageId = response.messageId {
                    try await db.collection("smsRequests").document(messageId).setData([
                        "orderId": orderId,
                        "trackingNumber": trackingNumber,
                        "customerPhone": customerPhone,
                        "requestedAt": FieldValue.serverTimestamp(),
                        "expiresAt": response.expiresAt ?? Date().addingTimeInterval(600),
                        "attemptsLeft": response.attemptsLeft
                    ])
                }
                
                return response.messageId ?? ""
            } else {
                throw KaspiAPIError.smsCodeError("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å SMS –∫–æ–¥")
            }
            
        } catch let error as NetworkError {
            switch error {
            case .serverError(_, let message):
                throw KaspiAPIError.smsCodeError(message ?? "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞")
            case .rateLimited:
                throw KaspiAPIError.rateLimitExceeded
            default:
                throw KaspiAPIError.networkError(error.localizedDescription)
            }
        } catch {
            throw KaspiAPIError.smsCodeError(error.localizedDescription)
        }
    }
    
    /// –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –¥–æ—Å—Ç–∞–≤–∫—É —Å –ø–æ–º–æ—â—å—é SMS –∫–æ–¥–∞
    func confirmDelivery(orderId: String, trackingNumber: String, smsCode: String) async throws -> Bool {
        guard let token = apiToken else {
            throw KaspiAPIError.tokenNotFound
        }
        
        let request = KaspiDeliveryConfirmationRequest(
            orderId: orderId,
            trackingNumber: trackingNumber,
            confirmationCode: smsCode
        )
        
        do {
            let response: KaspiDeliveryConfirmationResponse = try await networkManager.post(
                endpoint: Endpoints.confirmDelivery,
                body: request,
                apiToken: token
            )
            
            if response.success && response.confirmed {
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –≤ Firestore
                try await saveDeliveryConfirmation(
                    orderId: orderId,
                    trackingNumber: trackingNumber,
                    smsCode: smsCode,
                    confirmedAt: response.confirmedAt
                )
                
                return true
            } else {
                throw KaspiAPIError.smsCodeError(response.message ?? "–ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è")
            }
            
        } catch let error as NetworkError {
            switch error {
            case .serverError(_, let message):
                throw KaspiAPIError.smsCodeError(message ?? "–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ–¥–∞")
            default:
                throw KaspiAPIError.networkError(error.localizedDescription)
            }
        } catch {
            throw error
        }
    }
    
    /// –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –¥–æ—Å—Ç–∞–≤–∫–∏ –≤ Firestore
    private func saveDeliveryConfirmation(
        orderId: String,
        trackingNumber: String,
        smsCode: String,
        confirmedAt: Date?
    ) async throws {
        guard let userId = Auth.auth().currentUser?.uid else {
            throw KaspiAPIError.authenticationFailed
        }
        
        let confirmationData: [String: Any] = [
            "orderId": orderId,
            "trackingNumber": trackingNumber,
            "confirmationCode": smsCode,
            "confirmedAt": confirmedAt ?? Date(),
            "confirmedBy": userId,
            "syncedWithKaspi": true
        ]
        
        try await db.collection("deliveryConfirmations").document(orderId).setData(confirmationData)
    }
    
    // MARK: - Stock Management
    
    /// –û–±–Ω–æ–≤–∏—Ç—å –æ—Å—Ç–∞—Ç–∫–∏ —Ç–æ–≤–∞—Ä–∞
    func updateStock(productId: String, warehouseId: String, quantity: Int, operation: KaspiStockUpdateRequest.StockOperation = .set) async throws {
        guard let token = apiToken else {
            throw KaspiAPIError.tokenNotFound
        }
        
        let request = KaspiStockUpdateRequest(
            productId: productId,
            warehouseId: warehouseId,
            quantity: quantity,
            operation: operation
        )
        
        do {
            let response: KaspiStockUpdateResponse = try await networkManager.post(
                endpoint: Endpoints.updateStock,
                body: request,
                apiToken: token
            )
            
            if response.success {
                print("‚úÖ –û—Å—Ç–∞—Ç–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω—ã –¥–ª—è —Ç–æ–≤–∞—Ä–∞ \(productId): \(response.previousQuantity) -> \(response.newQuantity)")
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ Firestore
                if let userId = Auth.auth().currentUser?.uid {
                    let productRef = db.collection("sellers").document(userId)
                        .collection("products").document(productId)
                    
                    try await productRef.updateData([
                        "warehouseStock.\(warehouseId)": response.newQuantity,
                        "updatedAt": FieldValue.serverTimestamp()
                    ])
                }
            } else {
                throw KaspiAPIError.stockUpdateError("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å –æ—Å—Ç–∞—Ç–∫–∏")
            }
            
        } catch let error as NetworkError {
            switch error {
            case .serverError(_, let message):
                throw KaspiAPIError.stockUpdateError(message ?? "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞")
            default:
                throw KaspiAPIError.networkError(error.localizedDescription)
            }
        } catch {
            throw error
        }
    }
    
    // MARK: - Utility Methods
    
    func checkAPIHealth() async -> Bool {
        do {
            return try await validateToken()
        } catch {
            return false
        }
    }
    
    var apiStatistics: (requests: Int, lastSync: Date?) {
        // TODO: Implement request counting
        return (0, lastSyncDate)
    }
    
    // MARK: - Batch Operations
    
    /// –ó–∞–≥—Ä—É–∑–∏—Ç—å —Ç–æ–≤–∞—Ä—ã –ø–æ —Å–ø–∏—Å–∫—É ID
    func loadProductsByIds(_ productIds: [String]) async throws -> [Product] {
        guard let token = apiToken else {
            throw KaspiAPIError.tokenNotFound
        }
        
        var products: [Product] = []
        
        // –ó–∞–≥—Ä—É–∂–∞–µ–º —Ç–æ–≤–∞—Ä—ã –±–∞—Ç—á–∞–º–∏ –ø–æ 10
        for chunk in productIds.chunked(into: 10) {
            let requests = chunk.map { productId in
                networkManager.get(
                    endpoint: String(format: Endpoints.productDetail, productId),
                    apiToken: token
                ) as Future<KaspiProductResponse, Error>
            }
            
            // –ñ–¥–µ–º –≤—Å–µ –∑–∞–ø—Ä–æ—Å—ã –≤ –±–∞—Ç—á–µ
            let responses = try await withThrowingTaskGroup(of: KaspiProductResponse.self) { group in
                for request in requests {
                    group.addTask {
                        try await request.value
                    }
                }
                
                var results: [KaspiProductResponse] = []
                for try await response in group {
                    results.append(response)
                }
                return results
            }
            
            // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ –Ω–∞—à —Ñ–æ—Ä–º–∞—Ç
            let convertedProducts = responses.map { convertKaspiProductToProduct($0) }
            products.append(contentsOf: convertedProducts)
        }
        
        return products
    }
    
    /// –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Å–∫–ª–∞–¥–æ–≤
    func loadWarehouses() async throws -> [Warehouse] {
        guard let token = apiToken else {
            throw KaspiAPIError.tokenNotFound
        }
        
        struct KaspiWarehouse: Codable {
            let id: String
            let name: String
            let address: String
            let city: String
            let isActive: Bool
            
            enum CodingKeys: String, CodingKey {
                case id = "warehouse_id"
                case name
                case address
                case city
                case isActive = "is_active"
            }
        }
        
        let response: KaspiResponse<[KaspiWarehouse]> = try await networkManager.get(
            endpoint: Endpoints.warehouses,
            apiToken: token
        )
        
        guard let kaspiWarehouses = response.data else {
            throw KaspiAPIError.invalidResponse
        }
        
        return kaspiWarehouses.map { kaspiWarehouse in
            Warehouse(
                id: kaspiWarehouse.id,
                name: kaspiWarehouse.name,
                address: kaspiWarehouse.address,
                city: kaspiWarehouse.city,
                isActive: kaspiWarehouse.isActive
            )
        }
    }
}

// MARK: - Helper Extensions

extension Array {
    func chunked(into size: Int) -> [[Element]] {
        return stride(from: 0, to: count, by: size).map {
            Array(self[$0..<Swift.min($0 + size, count)])
        }
    }
}

// MARK: - Future extension for async/await

extension Future {
    var value: Output {
        get async throws {
            try await withCheckedThrowingContinuation { continuation in
                self.sink(
                    receiveCompletion: { completion in
                        if case .failure(let error) = completion {
                            continuation.resume(throwing: error)
                        }
                    },
                    receiveValue: { value in
                        continuation.resume(returning: value)
                    }
                )
                .store(in: &Set<AnyCancellable>())
            }
        }
    }
}

// MARK: - Warehouse Model

struct Warehouse: Identifiable, Codable {
    let id: String
    let name: String
    let address: String
    let city: String
    let isActive: Bool
}
