//
//  KaspiAPIService.swift
//  vektaApp
//
//  –ü–æ–ª–Ω–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Kaspi API
//

import Foundation
import FirebaseAuth
import FirebaseFirestore

// MARK: - Kaspi API Models

/// –ú–æ–¥–µ–ª—å —Ç–æ–≤–∞—Ä–∞ –∏–∑ Kaspi API
struct KaspiProductResponse: Codable {
    let id: String
    let sku: String
    let name: String
    let description: String?
    let price: Double
    let category: String
    let images: [String]
    let stock: KaspiStock
    let isActive: Bool
    
    enum CodingKeys: String, CodingKey {
        case id = "product_id"
        case sku
        case name
        case description
        case price
        case category
        case images
        case stock
        case isActive = "is_active"
    }
}

/// –û—Å—Ç–∞—Ç–∫–∏ —Ç–æ–≤–∞—Ä–∞ –ø–æ —Å–∫–ª–∞–¥–∞–º
struct KaspiStock: Codable {
    let total: Int
    let warehouses: [KaspiWarehouseStock]
}

/// –û—Å—Ç–∞—Ç–∫–∏ –Ω–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º —Å–∫–ª–∞–¥–µ
struct KaspiWarehouseStock: Codable {
    let warehouseId: String
    let warehouseName: String
    let quantity: Int
    let reserved: Int
    let available: Int
    
    enum CodingKeys: String, CodingKey {
        case warehouseId = "warehouse_id"
        case warehouseName = "warehouse_name"
        case quantity
        case reserved
        case available
    }
}

/// –û—Ç–≤–µ—Ç –Ω–∞ –∑–∞–ø—Ä–æ—Å SMS –∫–æ–¥–∞
struct KaspiSMSCodeRequest: Codable {
    let orderId: String
    let trackingNumber: String
    let customerPhone: String
    
    enum CodingKeys: String, CodingKey {
        case orderId = "order_id"
        case trackingNumber = "tracking_number"
        case customerPhone = "customer_phone"
    }
}

/// –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –¥–æ—Å—Ç–∞–≤–∫–∏
struct KaspiDeliveryConfirmation: Codable {
    let orderId: String
    let trackingNumber: String
    let confirmationCode: String
    let confirmedAt: Date?
    
    enum CodingKeys: String, CodingKey {
        case orderId = "order_id"
        case trackingNumber = "tracking_number"
        case confirmationCode = "confirmation_code"
        case confirmedAt = "confirmed_at"
    }
}

// MARK: - Errors

enum KaspiAPIError: LocalizedError {
    case tokenNotFound
    case invalidToken
    case networkError(String)
    case authenticationFailed
    case rateLimitExceeded
    case invalidResponse
    case syncFailed(String)
    case smsCodeError(String)
    
    var errorDescription: String? {
        switch self {
        case .tokenNotFound:
            return "API —Ç–æ–∫–µ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–±–∞–≤—å—Ç–µ —Ç–æ–∫–µ–Ω –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö."
        case .invalidToken:
            return "–ù–µ–≤–µ—Ä–Ω—ã–π API —Ç–æ–∫–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å —Ç–æ–∫–µ–Ω–∞."
        case .networkError(let message):
            return "–û—à–∏–±–∫–∞ —Å–µ—Ç–∏: \(message)"
        case .authenticationFailed:
            return "–û—à–∏–±–∫–∞ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≤–∞—à API —Ç–æ–∫–µ–Ω."
        case .rateLimitExceeded:
            return "–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
        case .invalidResponse:
            return "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –æ—Ç–≤–µ—Ç –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞"
        case .syncFailed(let message):
            return "–û—à–∏–±–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏: \(message)"
        case .smsCodeError(let message):
            return "–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ SMS –∫–æ–¥–∞: \(message)"
        }
    }
}

// MARK: - KaspiAPIService

@MainActor
class KaspiAPIService: ObservableObject {
    
    // MARK: - Published Properties
    
    @Published var isLoading = false
    @Published var errorMessage: String?
    @Published var lastSyncDate: Date?
    @Published var apiToken: String?
    @Published var syncProgress: Double = 0.0
    
    // MARK: - Private Properties
    
    private let db = Firestore.firestore()
    private var authListener: AuthStateDidChangeListenerHandle?
    private let baseURL = "https://kaspi.kz/merchantcabinet/api/v1"
    private let session = URLSession.shared
    
    // MARK: - Initialization
    
    init() {
        print("üîß KaspiAPIService –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
        setupAuthListener()
    }
    
    deinit {
        if let listener = authListener {
            Auth.auth().removeStateDidChangeListener(listener)
        }
    }
    
    // MARK: - Authentication
    
    private func setupAuthListener() {
        authListener = Auth.auth().addStateDidChangeListener { [weak self] _, user in
            Task { @MainActor in
                if user != nil {
                    await self?.loadApiToken()
                } else {
                    self?.apiToken = nil
                }
            }
        }
    }
    
    func loadApiToken() async {
        guard let userId = Auth.auth().currentUser?.uid else {
            print("‚ùå –ù–µ—Ç –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
            errorMessage = "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω"
            return
        }
        
        print("üîç –ó–∞–≥—Ä—É–∂–∞–µ–º —Ç–æ–∫–µ–Ω –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: \(userId)")
        
        do {
            let document = try await db.collection("sellers").document(userId).getDocument()
            
            if let data = document.data(),
               let token = data["kaspiApiToken"] as? String {
                apiToken = token
                errorMessage = nil
                print("‚úÖ Kaspi API —Ç–æ–∫–µ–Ω –∑–∞–≥—Ä—É–∂–µ–Ω")
            } else {
                print("‚ö†Ô∏è Kaspi API —Ç–æ–∫–µ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω")
                apiToken = nil
                errorMessage = "–¢–æ–∫–µ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω. –î–æ–±–∞–≤—å—Ç–µ —Ç–æ–∫–µ–Ω –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö."
            }
        } catch {
            print("‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ç–æ–∫–µ–Ω–∞: \(error.localizedDescription)")
            errorMessage = "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ç–æ–∫–µ–Ω–∞"
        }
    }
    
    func loadApiToken() {
        Task {
            await loadApiToken()
        }
    }
    
    // MARK: - API Methods
    
    /// –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å —Ç–æ–∫–µ–Ω–∞
    func validateToken() async throws -> Bool {
        guard let token = apiToken else {
            throw KaspiAPIError.tokenNotFound
        }
        
        // –î–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ - –∏–º–∏—Ç–∏—Ä—É–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É —Ç–æ–∫–µ–Ω–∞
        // –í —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ –∑–¥–µ—Å—å –±—É–¥–µ—Ç –∑–∞–ø—Ä–æ—Å –∫ Kaspi API
        
        try await Task.sleep(nanoseconds: 1_000_000_000) // 1 —Å–µ–∫—É–Ω–¥–∞
        
        // –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ–∫–µ–Ω–∞
        if token.count > 10 && !token.isEmpty {
            return true
        } else {
            throw KaspiAPIError.invalidToken
        }
    }
    
    /// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞—Ç—å –≤—Å–µ —Ç–æ–≤–∞—Ä—ã
    func syncAllProducts() async throws -> [Product] {
        guard let token = apiToken else {
            throw KaspiAPIError.tokenNotFound
        }
        
        isLoading = true
        errorMessage = nil
        syncProgress = 0.0
        
        do {
            // –í–∞–ª–∏–¥–∏—Ä—É–µ–º —Ç–æ–∫–µ–Ω
            let isValid = try await validateToken()
            guard isValid else {
                throw KaspiAPIError.invalidToken
            }
            
            // –ò–º–∏—Ç–∏—Ä—É–µ–º –∑–∞–≥—Ä—É–∑–∫—É —Ç–æ–≤–∞—Ä–æ–≤ –∏–∑ Kaspi API
            // –í —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ –∑–¥–µ—Å—å –±—É–¥–µ—Ç –∑–∞–ø—Ä–æ—Å –∫ API
            let products = try await simulateProductSync()
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ Firestore
            try await saveProductsToFirestore(products)
            
            isLoading = false
            lastSyncDate = Date()
            syncProgress = 1.0
            print("‚úÖ –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞! –ó–∞–≥—Ä—É–∂–µ–Ω–æ \(products.count) —Ç–æ–≤–∞—Ä–æ–≤")
            
            return products
            
        } catch {
            isLoading = false
            errorMessage = error.localizedDescription
            syncProgress = 0.0
            throw error
        }
    }
    
    /// –ò–º–∏—Ç–∞—Ü–∏—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ —Ç–æ–≤–∞—Ä–æ–≤ (–¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏)
    private func simulateProductSync() async throws -> [Product] {
        // –ò–º–∏—Ç–∏—Ä—É–µ–º –ø—Ä–æ—Ü–µ—Å—Å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
        for i in 0...10 {
            syncProgress = Double(i) / 10.0
            try await Task.sleep(nanoseconds: 200_000_000) // 0.2 —Å–µ–∫—É–Ω–¥—ã
        }
        
        // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ —Ç–æ–≤–∞—Ä—ã
        return Product.sampleProducts
    }
    
    /// –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç–æ–≤–∞—Ä—ã –≤ Firestore
    private func saveProductsToFirestore(_ products: [Product]) async throws {
        guard let userId = Auth.auth().currentUser?.uid else {
            throw KaspiAPIError.authenticationFailed
        }
        
        let batch = db.batch()
        let productsRef = db.collection("sellers").document(userId).collection("products")
        
        for product in products {
            let docRef = productsRef.document(product.id)
            batch.setData(product.toDictionary(), forDocument: docRef, merge: true)
        }
        
        try await batch.commit()
    }
    
    // MARK: - SMS Code & Delivery Confirmation
    
    /// –ó–∞–ø—Ä–æ—Å–∏—Ç—å SMS –∫–æ–¥ –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –¥–æ—Å—Ç–∞–≤–∫–∏
    func requestSMSCode(orderId: String, trackingNumber: String) async throws {
        guard let token = apiToken else {
            throw KaspiAPIError.tokenNotFound
        }
        
        // –ò–º–∏—Ç–∏—Ä—É–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É SMS –∫–æ–¥–∞
        try await Task.sleep(nanoseconds: 1_000_000_000) // 1 —Å–µ–∫—É–Ω–¥–∞
        
        print("‚úÖ SMS –∫–æ–¥ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∫–ª–∏–µ–Ω—Ç—É –¥–ª—è –∑–∞–∫–∞–∑–∞ \(orderId)")
    }
    
    /// –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –¥–æ—Å—Ç–∞–≤–∫—É —Å –ø–æ–º–æ—â—å—é SMS –∫–æ–¥–∞
    func confirmDelivery(orderId: String, trackingNumber: String, smsCode: String) async throws -> Bool {
        guard let token = apiToken else {
            throw KaspiAPIError.tokenNotFound
        }
        
        // –ò–º–∏—Ç–∏—Ä—É–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É SMS –∫–æ–¥–∞
        try await Task.sleep(nanoseconds: 500_000_000) // 0.5 —Å–µ–∫—É–Ω–¥—ã
        
        // –î–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ - –∫–æ–¥ "123456" –≤—Å–µ–≥–¥–∞ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π
        if smsCode == "123456" {
            try await saveDeliveryConfirmation(orderId: orderId, trackingNumber: trackingNumber, smsCode: smsCode)
            return true
        } else {
            throw KaspiAPIError.smsCodeError("–ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è")
        }
    }
    
    /// –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –¥–æ—Å—Ç–∞–≤–∫–∏ –≤ Firestore
    private func saveDeliveryConfirmation(orderId: String, trackingNumber: String, smsCode: String) async throws {
        guard let userId = Auth.auth().currentUser?.uid else {
            throw KaspiAPIError.authenticationFailed
        }
        
        let confirmationData: [String: Any] = [
            "orderId": orderId,
            "trackingNumber": trackingNumber,
            "confirmationCode": smsCode,
            "confirmedAt": FieldValue.serverTimestamp(),
            "confirmedBy": userId
        ]
        
        try await db.collection("deliveryConfirmations").document(orderId).setData(confirmationData)
    }
    
    // MARK: - Stock Management
    
    /// –û–±–Ω–æ–≤–∏—Ç—å –æ—Å—Ç–∞—Ç–∫–∏ —Ç–æ–≤–∞—Ä–∞
    func updateStock(productId: String, warehouseId: String, quantity: Int) async throws {
        guard let token = apiToken else {
            throw KaspiAPIError.tokenNotFound
        }
        
        // –ò–º–∏—Ç–∏—Ä—É–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ—Å—Ç–∞—Ç–∫–æ–≤
        try await Task.sleep(nanoseconds: 500_000_000) // 0.5 —Å–µ–∫—É–Ω–¥—ã
        
        print("‚úÖ –û—Å—Ç–∞—Ç–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω—ã –¥–ª—è —Ç–æ–≤–∞—Ä–∞ \(productId)")
    }
    
    // MARK: - Utility Methods
    
    func checkAPIHealth() async -> Bool {
        do {
            return try await validateToken()
        } catch {
            return false
        }
    }
    
    var apiStatistics: (requests: Int, lastSync: Date?) {
        return (0, lastSyncDate)
    }
}
