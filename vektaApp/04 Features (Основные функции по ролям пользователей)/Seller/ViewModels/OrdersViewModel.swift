//
//  OrdersViewModel.swift
//  vektaApp
//
//  Created by Almas Kadeshov on 02.07.2025.
//

import SwiftUI
import FirebaseFirestore
import FirebaseAuth
import CoreImage // ‚Üê –î–æ–±–∞–≤–∏–ª–∏ –∏–º–ø–æ—Ä—Ç –¥–ª—è QR-–∫–æ–¥–∞
import CoreImage.CIFilterBuiltins

// MARK: - Errors
enum OrdersError: LocalizedError {
    case authenticationRequired
    case networkError
    case invalidData
    case orderNotFound
    
    var errorDescription: String? {
        switch self {
        case .authenticationRequired:
            return "–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è"
        case .networkError:
            return "–û—à–∏–±–∫–∞ —Å–µ—Ç–∏"
        case .invalidData:
            return "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ"
        case .orderNotFound:
            return "–ó–∞–∫–∞–∑ –Ω–µ –Ω–∞–π–¥–µ–Ω"
        }
    }
}

// MARK: - Statistics
struct OrdersStatistics {
    let totalOrders: Int
    let totalValue: Double
    let averageOrderValue: Double
    let statusBreakdown: [OrderStatus: Int]
}

// üß† ViewModel –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–∞–∫–∞–∑–∞–º–∏ –Ω–∞ —Å–∫–ª–∞–¥
class OrdersViewModel: ObservableObject {
    
    // üìä –î–∞–Ω–Ω—ã–µ –∑–∞–∫–∞–∑–æ–≤
    @Published var orders: [Order] = []
    @Published var filteredOrders: [Order] = []
    
    // üîç –ü–æ–∏—Å–∫ –∏ —Ñ–∏–ª—å—Ç—Ä—ã
    @Published var searchText: String = "" {
        didSet {
            filterOrders()
        }
    }
    @Published var selectedStatus: OrderStatus? = nil {
        didSet {
            filterOrders()
        }
    }
    @Published var selectedWarehouse: String = "–í—Å–µ" {
        didSet {
            filterOrders()
        }
    }
    
    // üì± –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
    @Published var isLoading: Bool = false
    @Published var errorMessage: String?
    @Published var successMessage: String?
    @Published var isRefreshing: Bool = false
    
    // üî• Firebase
    private let db = Firestore.firestore()
    private var listener: ListenerRegistration?
    
    // üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    var totalOrders: Int { orders.count }
    var pendingOrders: Int { orders.filter { $0.status == .pending }.count }
    var shippedOrders: Int { orders.filter { $0.status == .shipped }.count }
    var completedOrders: Int { orders.filter { $0.status == .completed }.count }
    
    // üìö –î–æ—Å—Ç—É–ø–Ω—ã–µ —Å–∫–ª–∞–¥—ã
    var warehouses: [String] {
        let allWarehouses = orders.map { $0.warehouseName }
        let uniqueWarehouses = Array(Set(allWarehouses)).sorted()
        return ["–í—Å–µ"] + uniqueWarehouses
    }
    
    init() {
        loadOrders()
    }
    
    deinit {
        listener?.remove()
    }
    
    // MARK: - –û—Å–Ω–æ–≤–Ω—ã–µ –º–µ—Ç–æ–¥—ã
    
    // üì¶ –ó–∞–≥—Ä—É–∑–∏—Ç—å –∑–∞–∫–∞–∑—ã
    func loadOrders() {
        guard let userId = Auth.auth().currentUser?.uid else {
            errorMessage = "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω"
            return
        }
        
        isLoading = true
        errorMessage = nil
        
        // –î–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
        // –í –ø—Ä–æ–¥–∞–∫—à–Ω–µ –∑–¥–µ—Å—å –±—É–¥–µ—Ç –∑–∞–≥—Ä—É–∑–∫–∞ –∏–∑ Firestore
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            self.orders = Order.sampleOrders
            self.filterOrders()
            self.isLoading = false
        }
        
        // TODO: –†–µ–∞–ª—å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –∏–∑ Firestore
        /*
         listener = db.collection("sellers").document(userId)
         .collection("orders")
         .order(by: "createdAt", descending: true)
         .addSnapshotListener { [weak self] snapshot, error in
         
         DispatchQueue.main.async {
         self?.isLoading = false
         
         if let error = error {
         self?.errorMessage = "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: \(error.localizedDescription)"
         return
         }
         
         guard let documents = snapshot?.documents else {
         self?.orders = []
         self?.filterOrders()
         return
         }
         
         self?.orders = documents.compactMap { doc in
         Order.fromFirestore(doc.data(), id: doc.documentID)
         }
         
         self?.filterOrders()
         }
         }
         */
    }
    
    // üîÑ –û–±–Ω–æ–≤–∏—Ç—å –∑–∞–∫–∞–∑—ã
    func refreshOrders() {
        isRefreshing = true
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
            self.loadOrders()
            self.isRefreshing = false
        }
    }
    
    // üîç –§–∏–ª—å—Ç—Ä–æ–≤–∞—Ç—å –∑–∞–∫–∞–∑—ã
    private func filterOrders() {
        var filtered = orders
        
        // –§–∏–ª—å—Ç—Ä –ø–æ –ø–æ–∏—Å–∫—É
        if !searchText.isEmpty {
            filtered = filtered.filter { order in
                order.orderNumber.localizedCaseInsensitiveContains(searchText) ||
                order.warehouseName.localizedCaseInsensitiveContains(searchText) ||
                order.notes.localizedCaseInsensitiveContains(searchText) ||
                order.items.contains { item in
                    item.productName.localizedCaseInsensitiveContains(searchText)
                }
            }
        }
        
        // –§–∏–ª—å—Ç—Ä –ø–æ —Å—Ç–∞—Ç—É—Å—É
        if let status = selectedStatus {
            filtered = filtered.filter { $0.status == status }
        }
        
        // –§–∏–ª—å—Ç—Ä –ø–æ —Å–∫–ª–∞–¥—É
        if selectedWarehouse != "–í—Å–µ" {
            filtered = filtered.filter { $0.warehouseName == selectedWarehouse }
        }
        
        filteredOrders = filtered
    }
    
    // MARK: - –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–∫–∞–∑–æ–≤
    
    // ‚ûï –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –∑–∞–∫–∞–∑
    func createOrder(
        selectedProducts: [Product: Int], // –ü—Ä–æ–¥—É–∫—Ç –∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
        warehouseId: String,
        warehouseName: String,
        notes: String,
        priority: OrderPriority,
        estimatedDelivery: Date?
    ) async -> Bool {
        
        guard let userId = Auth.auth().currentUser?.uid,
              let userEmail = Auth.auth().currentUser?.email else {
            await MainActor.run {
                errorMessage = "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω"
            }
            return false
        }
        
        // ‚úÖ –î–æ–±–∞–≤–∏–ª–∏ –≤–∞–ª–∏–¥–∞—Ü–∏—é
        do {
            try validateOrderData(
                selectedProducts: selectedProducts,
                warehouseName: warehouseName,
                notes: notes
            )
        } catch {
            await MainActor.run {
                self.errorMessage = error.localizedDescription
            }
            return false
        }
        
        await MainActor.run {
            isLoading = true
            errorMessage = nil
        }
        
        // –°–æ–∑–¥–∞–µ–º —Ç–æ–≤–∞—Ä—ã –∑–∞–∫–∞–∑–∞
        let orderItems = selectedProducts.map { (product, quantity) in
            OrderItem(
                id: UUID().uuidString,
                productSKU: product.id,
                productName: product.name,
                quantity: quantity,
                price: product.price,
                imageURL: product.imageURL,
                category: product.category
            )
        }
        
        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –∑–∞–∫–∞–∑–∞
        let orderNumber = Order.generateOrderNumber()
        let qrData = Order.generateQRData(
            orderNumber: orderNumber,
            sellerId: userId,
            warehouseId: warehouseId
        )
        
        // –°–æ–∑–¥–∞–µ–º –∑–∞–∫–∞–∑
        let newOrder = Order(
            id: UUID().uuidString,
            orderNumber: orderNumber,
            sellerId: userId,
            sellerEmail: userEmail,
            warehouseId: warehouseId,
            warehouseName: warehouseName,
            items: orderItems,
            notes: notes,
            status: .pending,
            priority: priority,
            createdAt: Date(),
            updatedAt: Date(),
            estimatedDelivery: estimatedDelivery,
            qrCodeData: qrData
        )
        
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ Firestore
        do {
            try await saveOrderToFirestore(newOrder)
            
            await MainActor.run {
                // –î–æ–±–∞–≤–ª—è–µ–º –≤ –ª–æ–∫–∞–ª—å–Ω—ã–π —Å–ø–∏—Å–æ–∫
                self.orders.insert(newOrder, at: 0)
                self.filterOrders()
                self.isLoading = false
                self.successMessage = "‚úÖ –ó–∞–∫–∞–∑ \(orderNumber) —Å–æ–∑–¥–∞–Ω!"
                
                // –û—á–∏—â–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —á–µ—Ä–µ–∑ 3 —Å–µ–∫—É–Ω–¥—ã
                DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
                    self.successMessage = nil
                }
            }
            
            return true
            
        } catch {
            await MainActor.run {
                self.isLoading = false
                self.errorMessage = "–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–∫–∞–∑–∞: \(error.localizedDescription)"
            }
            return false
        }
    }
    
    // üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∑–∞–∫–∞–∑ –≤ Firestore
    private func saveOrderToFirestore(_ order: Order) async throws {
        guard let userId = Auth.auth().currentUser?.uid else {
            throw OrdersError.authenticationRequired
        }
        
        // TODO: –†–µ–∞–ª—å–Ω–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ Firestore
        // –ü–æ–∫–∞ –∏–º–∏—Ç–∏—Ä—É–µ–º –∑–∞–¥–µ—Ä–∂–∫—É
        try await Task.sleep(nanoseconds: 1_500_000_000) // 1.5 —Å–µ–∫—É–Ω–¥—ã
        
        /*
         let orderData = order.toDictionary()
         try await db.collection("sellers").document(userId)
         .collection("orders").document(order.id)
         .setData(orderData)
         */
    }
    
    // MARK: - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∑–∞–∫–∞–∑–∞–º–∏
    
    // üìù –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞ (–£–õ–£–ß–®–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø)
    func updateOrderStatus(_ order: Order, newStatus: OrderStatus) async {
        await MainActor.run {
            isLoading = true
            errorMessage = nil
        }
        
        do {
            // –ù–∞—Ö–æ–¥–∏–º –∏–Ω–¥–µ–∫—Å –∑–∞–∫–∞–∑–∞
            guard let index = orders.firstIndex(where: { $0.id == order.id }) else {
                throw OrdersError.orderNotFound
            }
            
            // –°–æ–∑–¥–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –∑–∞–∫–∞–∑ (–Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã–π –ø–æ–¥—Ö–æ–¥)
            let updatedOrder = order.updatingStatus(newStatus)
            
            // TODO: –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ Firestore
            try await saveOrderToFirestore(updatedOrder)
            
            await MainActor.run {
                // –û–±–Ω–æ–≤–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                self.orders[index] = updatedOrder
                self.filterOrders()
                self.isLoading = false
                self.successMessage = "‚úÖ –°—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞ –æ–±–Ω–æ–≤–ª–µ–Ω"
                
                // –û—á–∏—â–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —á–µ—Ä–µ–∑ 3 —Å–µ–∫—É–Ω–¥—ã
                DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
                    self.successMessage = nil
                }
            }
            
        } catch {
            await MainActor.run {
                self.isLoading = false
                self.errorMessage = error.localizedDescription
            }
        }
    }
    
    // üóëÔ∏è –û—Ç–º–µ–Ω–∏—Ç—å –∑–∞–∫–∞–∑
    func cancelOrder(_ order: Order) async {
        await updateOrderStatus(order, newStatus: .cancelled)
    }
    
    // üì¶ –û—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞–∫–∞–∑
    func shipOrder(_ order: Order) async {
        await updateOrderStatus(order, newStatus: .shipped)
    }
    
    // MARK: - QR-–∫–æ–¥ –≥–µ–Ω–µ—Ä–∞—Ü–∏—è
    
    // üè∑Ô∏è –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å QR-–∫–æ–¥ –¥–ª—è –∑–∞–∫–∞–∑–∞
    func generateQRCode(for order: Order) -> String {
        return order.qrCodeData
    }
    
    func createQRCodeImage(from string: String) -> UIImage? {
        // –°–æ–∫—Ä–∞—Ç–∏–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è QR-–∫–æ–¥–∞
        let qrData = createCompactQRData(from: string)
        
        guard let data = qrData.data(using: .utf8) else {
            print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å —Å—Ç—Ä–æ–∫—É –≤ Data")
            return nil
        }
        
        guard let filter = CIFilter(name: "CIQRCodeGenerator") else {
            print("‚ùå QR —Ñ–∏–ª—å—Ç—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω")
            return nil
        }
        
        filter.setValue(data, forKey: "inputMessage")
        filter.setValue("H", forKey: "inputCorrectionLevel") // –í—ã—Å–æ–∫–∏–π —É—Ä–æ–≤–µ–Ω—å –∫–æ—Ä—Ä–µ–∫—Ü–∏–∏
        
        guard let outputImage = filter.outputImage else {
            print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å QR –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ")
            return nil
        }
        
        // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä QR-–∫–æ–¥–∞
        let scaleX = 300.0 / outputImage.extent.size.width
        let scaleY = 300.0 / outputImage.extent.size.height
        let transformedImage = outputImage.transformed(by: CGAffineTransform(scaleX: scaleX, y: scaleY))
        
        let context = CIContext()
        guard let cgImage = context.createCGImage(transformedImage, from: transformedImage.extent) else {
            print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å CGImage")
            return nil
        }
        
        print("‚úÖ QR-–∫–æ–¥ —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω")
        return UIImage(cgImage: cgImage)
    }
    private func createCompactQRData(from originalData: String) -> String {
        // –ò–∑–≤–ª–µ–∫–∞–µ–º –Ω–æ–º–µ—Ä –∑–∞–∫–∞–∑–∞ –∏–∑ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        let components = originalData.split(separator: ":")
        if components.count >= 2 {
            let orderNumber = String(components[1])
            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–æ–ª—å–∫–æ –Ω–æ–º–µ—Ä –∑–∞–∫–∞–∑–∞ - —ç—Ç–æ–≥–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–ª—è –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
            return orderNumber
        }
        
        // –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–≤—ã–µ 50 —Å–∏–º–≤–æ–ª–æ–≤
        return String(originalData.prefix(50))
        
        // MARK: - –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã
        
        // üé® –ü–æ–ª—É—á–∏—Ç—å —Ü–≤–µ—Ç –¥–ª—è —Å—Ç–∞—Ç—É—Å–∞
        func colorForStatus(_ status: OrderStatus) -> Color {
            switch status {
            case .draft: return .gray
            case .pending: return .orange
            case .shipped: return .blue
            case .received: return .green
            case .completed: return .green
            case .cancelled: return .red
            }
        }
        
        // üîç –û—á–∏—Å—Ç–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä—ã
        func clearFilters() {
            searchText = ""
            selectedStatus = nil
            selectedWarehouse = "–í—Å–µ"
        }
        
        // üìä –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ—Ü–µ–Ω—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö –∑–∞–∫–∞–∑–æ–≤
        var completionPercentage: Double {
            guard totalOrders > 0 else { return 0 }
            return Double(completedOrders) / Double(totalOrders) * 100
        }
        
        // üí∞ –û–±—â–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å –≤—Å–µ—Ö –∑–∞–∫–∞–∑–æ–≤
        var totalOrdersValue: Double {
            orders.reduce(0) { $0 + $1.totalValue }
        }
        
        var formattedTotalValue: String {
            let formatter = NumberFormatter()
            formatter.numberStyle = .currency
            formatter.currencyCode = "KZT"
            formatter.maximumFractionDigits = 0
            return formatter.string(from: NSNumber(value: totalOrdersValue)) ?? "\(Int(totalOrdersValue)) ‚Ç∏"
        }
        
        // üîç –ù–∞–π—Ç–∏ –∑–∞–∫–∞–∑ –ø–æ ID
        func findOrder(by id: String) -> Order? {
            return orders.first { $0.id == id }
        }
        
        // üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ –ø–µ—Ä–∏–æ–¥
        func getOrdersStatistics(for period: DateInterval) -> OrdersStatistics {
            let periodOrders = orders.filter { period.contains($0.createdAt) }
            
            return OrdersStatistics(
                totalOrders: periodOrders.count,
                totalValue: periodOrders.reduce(0) { $0 + $1.totalValue },
                averageOrderValue: periodOrders.isEmpty ? 0 : periodOrders.reduce(0) { $0 + $1.totalValue } / Double(periodOrders.count),
                statusBreakdown: Dictionary(grouping: periodOrders, by: { $0.status })
                    .mapValues { $0.count }
            )
        }
        
        // ‚úÖ –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö –∑–∞–∫–∞–∑–∞
        private func validateOrderData(
            selectedProducts: [Product: Int],
            warehouseName: String,
            notes: String
        ) throws {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –≤—ã–±—Ä–∞–Ω—ã —Ç–æ–≤–∞—Ä—ã
            guard !selectedProducts.isEmpty else {
                throw OrdersError.invalidData
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –≤—ã–±—Ä–∞–Ω —Å–∫–ª–∞–¥
            guard !warehouseName.trimmingCharacters(in: .whitespaces).isEmpty else {
                throw OrdersError.invalidData
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ
            for (_, quantity) in selectedProducts {
                guard quantity > 0 else {
                    throw OrdersError.invalidData
                }
            }
        }
    }
    
    // MARK: - –†–∞—Å—à–∏—Ä–µ–Ω–∏—è –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞
    extension OrdersViewModel {
        
        // üìÖ –ó–∞–∫–∞–∑—ã –∑–∞ —Å–µ–≥–æ–¥–Ω—è
        var todayOrders: [Order] {
            let today = Calendar.current.startOfDay(for: Date())
            let tomorrow = Calendar.current.date(byAdding: .day, value: 1, to: today)!
            
            return orders.filter { order in
                order.createdAt >= today && order.createdAt < tomorrow
            }
        }
        
        // ‚ö° –°—Ä–æ—á–Ω—ã–µ –∑–∞–∫–∞–∑—ã
        var urgentOrders: [Order] {
            orders.filter { $0.priority == .urgent && $0.status != .completed && $0.status != .cancelled }
        }
        
        // üì¶ –ó–∞–∫–∞–∑—ã –≥–æ—Ç–æ–≤—ã–µ –∫ –æ—Ç–ø—Ä–∞–≤–∫–µ
        var readyToShipOrders: [Order] {
            orders.filter { $0.status == .pending }
        }
    }
}
