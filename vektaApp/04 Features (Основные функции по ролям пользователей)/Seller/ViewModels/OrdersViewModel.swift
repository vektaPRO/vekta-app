//
//  OrdersViewModel.swift
//  vektaApp
//
//  Created by Almas Kadeshov on 02.07.2025.
//

import SwiftUI
import FirebaseFirestore
import FirebaseAuth

// üß† ViewModel –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–∞–∫–∞–∑–∞–º–∏ –Ω–∞ —Å–∫–ª–∞–¥
class OrdersViewModel: ObservableObject {
    
    // üìä –î–∞–Ω–Ω—ã–µ –∑–∞–∫–∞–∑–æ–≤
    @Published var orders: [Order] = []
    @Published var filteredOrders: [Order] = []
    
    // üîç –ü–æ–∏—Å–∫ –∏ —Ñ–∏–ª—å—Ç—Ä—ã
    @Published var searchText: String = "" {
        didSet {
            filterOrders()
        }
    }
    @Published var selectedStatus: OrderStatus? = nil {
        didSet {
            filterOrders()
        }
    }
    @Published var selectedWarehouse: String = "–í—Å–µ" {
        didSet {
            filterOrders()
        }
    }
    
    // üì± –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
    @Published var isLoading: Bool = false
    @Published var errorMessage: String?
    @Published var successMessage: String?
    @Published var isRefreshing: Bool = false
    
    // üî• Firebase
    private let db = Firestore.firestore()
    private var listener: ListenerRegistration?
    
    // üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    var totalOrders: Int { orders.count }
    var pendingOrders: Int { orders.filter { $0.status == .pending }.count }
    var shippedOrders: Int { orders.filter { $0.status == .shipped }.count }
    var completedOrders: Int { orders.filter { $0.status == .completed }.count }
    
    // üìö –î–æ—Å—Ç—É–ø–Ω—ã–µ —Å–∫–ª–∞–¥—ã
    var warehouses: [String] {
        let allWarehouses = orders.map { $0.warehouseName }
        let uniqueWarehouses = Array(Set(allWarehouses)).sorted()
        return ["–í—Å–µ"] + uniqueWarehouses
    }
    
    init() {
        loadOrders()
    }
    
    deinit {
        listener?.remove()
    }
    
    // MARK: - –û—Å–Ω–æ–≤–Ω—ã–µ –º–µ—Ç–æ–¥—ã
    
    // üì¶ –ó–∞–≥—Ä—É–∑–∏—Ç—å –∑–∞–∫–∞–∑—ã
    func loadOrders() {
        guard let userId = Auth.auth().currentUser?.uid else {
            errorMessage = "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω"
            return
        }
        
        isLoading = true
        errorMessage = nil
        
        // –î–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
        // –í –ø—Ä–æ–¥–∞–∫—à–Ω–µ –∑–¥–µ—Å—å –±—É–¥–µ—Ç –∑–∞–≥—Ä—É–∑–∫–∞ –∏–∑ Firestore
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            self.orders = Order.sampleOrders
            self.filterOrders()
            self.isLoading = false
        }
        
        // TODO: –†–µ–∞–ª—å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –∏–∑ Firestore
        /*
        listener = db.collection("sellers").document(userId)
            .collection("orders")
            .order(by: "createdAt", descending: true)
            .addSnapshotListener { [weak self] snapshot, error in
                
                DispatchQueue.main.async {
                    self?.isLoading = false
                    
                    if let error = error {
                        self?.errorMessage = "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: \(error.localizedDescription)"
                        return
                    }
                    
                    guard let documents = snapshot?.documents else {
                        self?.orders = []
                        self?.filterOrders()
                        return
                    }
                    
                    self?.orders = documents.compactMap { doc in
                        Order.fromFirestore(doc.data(), id: doc.documentID)
                    }
                    
                    self?.filterOrders()
                }
            }
        */
    }
    
    // üîÑ –û–±–Ω–æ–≤–∏—Ç—å –∑–∞–∫–∞–∑—ã
    func refreshOrders() {
        isRefreshing = true
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
            self.loadOrders()
            self.isRefreshing = false
        }
    }
    
    // üîç –§–∏–ª—å—Ç—Ä–æ–≤–∞—Ç—å –∑–∞–∫–∞–∑—ã
    private func filterOrders() {
        var filtered = orders
        
        // –§–∏–ª—å—Ç—Ä –ø–æ –ø–æ–∏—Å–∫—É
        if !searchText.isEmpty {
            filtered = filtered.filter { order in
                order.orderNumber.localizedCaseInsensitiveContains(searchText) ||
                order.warehouseName.localizedCaseInsensitiveContains(searchText) ||
                order.notes.localizedCaseInsensitiveContains(searchText) ||
                order.items.contains { item in
                    item.productName.localizedCaseInsensitiveContains(searchText)
                }
            }
        }
        
        // –§–∏–ª—å—Ç—Ä –ø–æ —Å—Ç–∞—Ç—É—Å—É
        if let status = selectedStatus {
            filtered = filtered.filter { $0.status == status }
        }
        
        // –§–∏–ª—å—Ç—Ä –ø–æ —Å–∫–ª–∞–¥—É
        if selectedWarehouse != "–í—Å–µ" {
            filtered = filtered.filter { $0.warehouseName == selectedWarehouse }
        }
        
        filteredOrders = filtered
    }
    
    // MARK: - –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–∫–∞–∑–æ–≤
    
    // ‚ûï –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –∑–∞–∫–∞–∑
    func createOrder(
        selectedProducts: [Product: Int], // –ü—Ä–æ–¥—É–∫—Ç –∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
        warehouseId: String,
        warehouseName: String,
        notes: String,
        priority: OrderPriority,
        estimatedDelivery: Date?
    ) async -> Bool {
        
        guard let userId = Auth.auth().currentUser?.uid,
              let userEmail = Auth.auth().currentUser?.email else {
            await MainActor.run {
                errorMessage = "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω"
            }
            return false
        }
        
        await MainActor.run {
            isLoading = true
            errorMessage = nil
        }
        
        // –°–æ–∑–¥–∞–µ–º —Ç–æ–≤–∞—Ä—ã –∑–∞–∫–∞–∑–∞
        let orderItems = selectedProducts.map { (product, quantity) in
            OrderItem(
                id: UUID().uuidString,
                productSKU: product.id,
                productName: product.name,
                quantity: quantity,
                price: product.price,
                imageURL: product.imageURL,
                category: product.category
            )
        }
        
        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –∑–∞–∫–∞–∑–∞
        let orderNumber = Order.generateOrderNumber()
        let qrData = Order.generateQRData(
            orderNumber: orderNumber,
            sellerId: userId,
            warehouseId: warehouseId
        )
        
        // –°–æ–∑–¥–∞–µ–º –∑–∞–∫–∞–∑
        let newOrder = Order(
            id: UUID().uuidString,
            orderNumber: orderNumber,
            sellerId: userId,
            sellerEmail: userEmail,
            warehouseId: warehouseId,
            warehouseName: warehouseName,
            items: orderItems,
            notes: notes,
            status: .pending,
            priority: priority,
            createdAt: Date(),
            updatedAt: Date(),
            estimatedDelivery: estimatedDelivery,
            qrCodeData: qrData
        )
        
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ Firestore
        do {
            try await saveOrderToFirestore(newOrder)
            
            await MainActor.run {
                // –î–æ–±–∞–≤–ª—è–µ–º –≤ –ª–æ–∫–∞–ª—å–Ω—ã–π —Å–ø–∏—Å–æ–∫
                self.orders.insert(newOrder, at: 0)
                self.filterOrders()
                self.isLoading = false
                self.successMessage = "‚úÖ –ó–∞–∫–∞–∑ \(orderNumber) —Å–æ–∑–¥–∞–Ω!"
                
                // –û—á–∏—â–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —á–µ—Ä–µ–∑ 3 —Å–µ–∫—É–Ω–¥—ã
                DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
                    self.successMessage = nil
                }
            }
            
            return true
            
        } catch {
            await MainActor.run {
                self.isLoading = false
                self.errorMessage = "–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–∫–∞–∑–∞: \(error.localizedDescription)"
            }
            return false
        }
    }
    
    // üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∑–∞–∫–∞–∑ –≤ Firestore
    private func saveOrderToFirestore(_ order: Order) async throws {
        guard let userId = Auth.auth().currentUser?.uid else {
            throw NSError(domain: "AuthError", code: 401, userInfo: [NSLocalizedDescriptionKey: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω"])
        }
        
        // TODO: –†–µ–∞–ª—å–Ω–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ Firestore
        // –ü–æ–∫–∞ –∏–º–∏—Ç–∏—Ä—É–µ–º –∑–∞–¥–µ—Ä–∂–∫—É
        try await Task.sleep(nanoseconds: 1_500_000_000) // 1.5 —Å–µ–∫—É–Ω–¥—ã
        
        /*
        let orderData = order.toDictionary()
        try await db.collection("sellers").document(userId)
            .collection("orders").document(order.id)
            .setData(orderData)
        */
    }
    
    // MARK: - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∑–∞–∫–∞–∑–∞–º–∏
    
    // üìù –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞
    func updateOrderStatus(_ order: Order, newStatus: OrderStatus) async {
        await MainActor.run {
            isLoading = true
        }
        
        // TODO: –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤ Firestore
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            if let index = self.orders.firstIndex(where: { $0.id == order.id }) {
                var updatedOrder = self.orders[index]
                // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å (—ç—Ç–æ —É–ø—Ä–æ—â–µ–Ω–∏–µ, –≤ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –Ω—É–∂–Ω–æ —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π Order)
                self.orders[index] = Order(
                    id: updatedOrder.id,
                    orderNumber: updatedOrder.orderNumber,
                    sellerId: updatedOrder.sellerId,
                    sellerEmail: updatedOrder.sellerEmail,
                    warehouseId: updatedOrder.warehouseId,
                    warehouseName: updatedOrder.warehouseName,
                    items: updatedOrder.items,
                    notes: updatedOrder.notes,
                    status: newStatus,
                    priority: updatedOrder.priority,
                    createdAt: updatedOrder.createdAt,
                    updatedAt: Date(),
                    estimatedDelivery: updatedOrder.estimatedDelivery,
                    qrCodeData: updatedOrder.qrCodeData
                )
                self.filterOrders()
            }
            self.isLoading = false
            self.successMessage = "–°—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞ –æ–±–Ω–æ–≤–ª–µ–Ω"
        }
    }
    
    // üóëÔ∏è –û—Ç–º–µ–Ω–∏—Ç—å –∑–∞–∫–∞–∑
    func cancelOrder(_ order: Order) async {
        await updateOrderStatus(order, newStatus: .cancelled)
    }
    
    // üì¶ –û—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞–∫–∞–∑
    func shipOrder(_ order: Order) async {
        await updateOrderStatus(order, newStatus: .shipped)
    }
    
    // MARK: - QR-–∫–æ–¥ –≥–µ–Ω–µ—Ä–∞—Ü–∏—è
    
    // üè∑Ô∏è –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å QR-–∫–æ–¥ –¥–ª—è –∑–∞–∫–∞–∑–∞
    func generateQRCode(for order: Order) -> String {
        return order.qrCodeData
    }
    
    // üñºÔ∏è –°–æ–∑–¥–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ QR-–∫–æ–¥–∞
    func createQRCodeImage(from string: String) -> UIImage? {
        let data = string.data(using: String.Encoding.ascii)
        
        if let filter = CIFilter(name: "CIQRCodeGenerator") {
            filter.setValue(data, forKey: "inputMessage")
            let transform = CGAffineTransform(scaleX: 3, y: 3)
            
            if let output = filter.outputImage?.transformed(by: transform) {
                let context = CIContext()
                if let cgImage = context.createCGImage(output, from: output.extent) {
                    return UIImage(cgImage: cgImage)
                }
            }
        }
        
        return nil
    }
    
    // MARK: - –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã
    
    // üé® –ü–æ–ª—É—á–∏—Ç—å —Ü–≤–µ—Ç –¥–ª—è —Å—Ç–∞—Ç—É—Å–∞
    func colorForStatus(_ status: OrderStatus) -> Color {
        switch status {
        case .draft: return .gray
        case .pending: return .orange
        case .shipped: return .blue
        case .received: return .green
        case .completed: return .green
        case .cancelled: return .red
        }
    }
    
    // üîç –û—á–∏—Å—Ç–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä—ã
    func clearFilters() {
        searchText = ""
        selectedStatus = nil
        selectedWarehouse = "–í—Å–µ"
    }
    
    // üìä –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ—Ü–µ–Ω—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö –∑–∞–∫–∞–∑–æ–≤
    var completionPercentage: Double {
        guard totalOrders > 0 else { return 0 }
        return Double(completedOrders) / Double(totalOrders) * 100
    }
    
    // üí∞ –û–±—â–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å –≤—Å–µ—Ö –∑–∞–∫–∞–∑–æ–≤
    var totalOrdersValue: Double {
        orders.reduce(0) { $0 + $1.totalValue }
    }
    
    var formattedTotalValue: String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .currency
        formatter.currencyCode = "KZT"
        formatter.maximumFractionDigits = 0
        return formatter.string(from: NSNumber(value: totalOrdersValue)) ?? "\(Int(totalOrdersValue)) ‚Ç∏"
    }
}

// MARK: - –†–∞—Å—à–∏—Ä–µ–Ω–∏—è –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞
extension OrdersViewModel {
    
    // üìÖ –ó–∞–∫–∞–∑—ã –∑–∞ —Å–µ–≥–æ–¥–Ω—è
    var todayOrders: [Order] {
        let today = Calendar.current.startOfDay(for: Date())
        let tomorrow = Calendar.current.date(byAdding: .day, value: 1, to: today)!
        
        return orders.filter { order in
            order.createdAt >= today && order.createdAt < tomorrow
        }
    }
    
    // ‚ö° –°—Ä–æ—á–Ω—ã–µ –∑–∞–∫–∞–∑—ã
    var urgentOrders: [Order] {
        orders.filter { $0.priority == .urgent && $0.status != .completed && $0.status != .cancelled }
    }
    
    // üì¶ –ó–∞–∫–∞–∑—ã –≥–æ—Ç–æ–≤—ã–µ –∫ –æ—Ç–ø—Ä–∞–≤–∫–µ
    var readyToShipOrders: [Order] {
        orders.filter { $0.status == .pending }
    }
}
