//
//  CourierDeliveryViewModel.swift
//  vektaApp
//
//  ViewModel –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–æ—Å—Ç–∞–≤–∫–∞–º–∏ –∫—É—Ä—å–µ—Ä–æ–º
//

import SwiftUI
import FirebaseFirestore
import FirebaseAuth
import CoreLocation

@MainActor
class CourierDeliveryViewModel: ObservableObject {
    
    // MARK: - Published Properties
    
    @Published var activeDeliveries: [DeliveryConfirmation] = []
    @Published var completedDeliveries: [DeliveryConfirmation] = []
    @Published var currentDelivery: DeliveryConfirmation?
    
    @Published var enteredCode: String = ""
    @Published var isLoading = false
    @Published var errorMessage: String?
    @Published var successMessage: String?
    
    @Published var isRequestingSMS = false
    @Published var isVerifyingCode = false
    
    // MARK: - Private Properties
    
    private let db = Firestore.firestore()
    private let kaspiService = KaspiAPIService()
    private var listener: ListenerRegistration?
    
    // MARK: - Statistics
    
    var todayDeliveries: Int {
        let today = Calendar.current.startOfDay(for: Date())
        return completedDeliveries.filter { delivery in
            guard let confirmedAt = delivery.confirmedAt else { return false }
            return confirmedAt >= today
        }.count
    }
    
    var pendingDeliveries: Int {
        activeDeliveries.filter { $0.status == .pending || $0.status == .inTransit }.count
    }
    
    // MARK: - Initialization
    
    init() {
        loadDeliveries()
    }
    
    deinit {
        listener?.remove()
    }
    
    // MARK: - Load Deliveries
    
    func loadDeliveries() {
        guard let courierId = Auth.auth().currentUser?.uid else {
            errorMessage = "–ö—É—Ä—å–µ—Ä –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω"
            return
        }
        
        isLoading = true
        
        // –°–ª—É—à–∞–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ –¥–æ—Å—Ç–∞–≤–∫–∏
        listener = db.collection("deliveries")
            .whereField("courierId", isEqualTo: courierId)
            .whereField("status", notIn: [DeliveryStatus.confirmed.rawValue, DeliveryStatus.cancelled.rawValue])
            .addSnapshotListener { [weak self] snapshot, error in
                guard let self = self else { return }
                
                DispatchQueue.main.async {
                    self.isLoading = false
                    
                    if let error = error {
                        self.errorMessage = "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: \(error.localizedDescription)"
                        return
                    }
                    
                    guard let documents = snapshot?.documents else {
                        self.activeDeliveries = []
                        return
                    }
                    
                    self.activeDeliveries = documents.compactMap { doc in
                        DeliveryConfirmation.fromFirestore(doc.data(), id: doc.documentID)
                    }.sorted { $0.createdAt > $1.createdAt }
                }
            }
        
        // –ó–∞–≥—Ä—É–∂–∞–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ –¥–æ—Å—Ç–∞–≤–∫–∏ –∑–∞ —Å–µ–≥–æ–¥–Ω—è
        loadCompletedDeliveries()
    }
    
    private func loadCompletedDeliveries() {
        guard let courierId = Auth.auth().currentUser?.uid else { return }
        
        let today = Calendar.current.startOfDay(for: Date())
        
        db.collection("deliveries")
            .whereField("courierId", isEqualTo: courierId)
            .whereField("status", isEqualTo: DeliveryStatus.confirmed.rawValue)
            .whereField("confirmedAt", isGreaterThanOrEqualTo: Timestamp(date: today))
            .getDocuments { [weak self] snapshot, error in
                guard let self = self else { return }
                
                DispatchQueue.main.async {
                    if let documents = snapshot?.documents {
                        self.completedDeliveries = documents.compactMap { doc in
                            DeliveryConfirmation.fromFirestore(doc.data(), id: doc.documentID)
                        }
                    }
                }
            }
    }
    
    // MARK: - Delivery Actions
    
    /// –ù–∞—á–∞—Ç—å –¥–æ—Å—Ç–∞–≤–∫—É
    func startDelivery(_ delivery: DeliveryConfirmation) async {
        isLoading = true
        errorMessage = nil
        
        do {
            let updated = delivery.updatingStatus(.inTransit)
            try await updateDeliveryInFirestore(updated)
            
            // –î–æ–±–∞–≤–ª—è–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é
            try await addToHistory(
                deliveryId: delivery.id,
                action: .started,
                details: "–ö—É—Ä—å–µ—Ä –≤—ã–µ—Ö–∞–ª –∫ –∫–ª–∏–µ–Ω—Ç—É"
            )
            
            currentDelivery = updated
            successMessage = "‚úÖ –î–æ—Å—Ç–∞–≤–∫–∞ –Ω–∞—á–∞—Ç–∞"
            
        } catch {
            errorMessage = "–û—à–∏–±–∫–∞: \(error.localizedDescription)"
        }
        
        isLoading = false
    }
    
    /// –ü—Ä–∏–±—ã—Ç—å –∫ –∫–ª–∏–µ–Ω—Ç—É
    func arrivedAtCustomer(_ delivery: DeliveryConfirmation) async {
        isLoading = true
        errorMessage = nil
        
        do {
            let updated = delivery.updatingStatus(.arrived)
            try await updateDeliveryInFirestore(updated)
            
            // –î–æ–±–∞–≤–ª—è–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é —Å –≥–µ–æ–ª–æ–∫–∞—Ü–∏–µ–π
            try await addToHistory(
                deliveryId: delivery.id,
                action: .arrived,
                details: "–ö—É—Ä—å–µ—Ä –ø—Ä–∏–±—ã–ª –ø–æ –∞–¥—Ä–µ—Å—É: \(delivery.deliveryAddress)",
                location: nil // TODO: –î–æ–±–∞–≤–∏—Ç—å —Ä–µ–∞–ª—å–Ω—É—é –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é
            )
            
            currentDelivery = updated
            successMessage = "‚úÖ –í—ã –ø—Ä–∏–±—ã–ª–∏ –∫ –∫–ª–∏–µ–Ω—Ç—É"
            
        } catch {
            errorMessage = "–û—à–∏–±–∫–∞: \(error.localizedDescription)"
        }
        
        isLoading = false
    }
    
    // MARK: - SMS Code Management
    
    /// –ó–∞–ø—Ä–æ—Å–∏—Ç—å SMS –∫–æ–¥
    func requestSMSCode(for delivery: DeliveryConfirmation) async {
        isRequestingSMS = true
        errorMessage = nil
        
        do {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–Ω–æ –ª–∏ –∑–∞–ø—Ä–æ—Å–∏—Ç—å –Ω–æ–≤—ã–π –∫–æ–¥
            guard delivery.canRequestNewCode else {
                throw NSError(
                    domain: "CourierDelivery",
                    code: 1,
                    userInfo: [NSLocalizedDescriptionKey: "–ü–æ–¥–æ–∂–¥–∏—Ç–µ 2 –º–∏–Ω—É—Ç—ã –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–Ω—ã–º –∑–∞–ø—Ä–æ—Å–æ–º"]
                )
            }
            
            // –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –∫–æ–¥ —á–µ—Ä–µ–∑ Kaspi API
            try await kaspiService.requestSMSCode(
                orderId: delivery.orderId,
                trackingNumber: delivery.trackingNumber
            )
            
            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–æ–¥ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è (–≤ –ø—Ä–æ–¥–∞–∫—à–Ω–µ –∫–æ–¥ –ø—Ä–∏–¥–µ—Ç –æ—Ç Kaspi)
            let code = generateTestSMSCode()
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –¥–æ—Å—Ç–∞–≤–∫—É —Å –∫–æ–¥–æ–º
            var updated = delivery.withConfirmationCode(code)
            updated.status = .awaitingCode
            
            try await updateDeliveryInFirestore(updated)
            
            // –î–æ–±–∞–≤–ª—è–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é
            try await addToHistory(
                deliveryId: delivery.id,
                action: .codeRequested,
                details: "SMS –∫–æ–¥ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ –Ω–æ–º–µ—Ä \(delivery.formattedPhone)"
            )
            
            currentDelivery = updated
            successMessage = "‚úÖ SMS –∫–æ–¥ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∫–ª–∏–µ–Ω—Ç—É"
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–æ–¥ –∫—É—Ä—å–µ—Ä—É –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
            #if DEBUG
            print("üîê –¢–µ—Å—Ç–æ–≤—ã–π SMS –∫–æ–¥: \(code)")
            #endif
            
        } catch {
            errorMessage = error.localizedDescription
        }
        
        isRequestingSMS = false
    }
    
    /// –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –¥–æ—Å—Ç–∞–≤–∫—É —Å –ø–æ–º–æ—â—å—é –∫–æ–¥–∞
    func confirmDeliveryWithCode(_ code: String, for delivery: DeliveryConfirmation) async {
        guard !code.isEmpty else {
            errorMessage = "–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è"
            return
        }
        
        isVerifyingCode = true
        errorMessage = nil
        
        do {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫
            guard delivery.remainingAttempts > 0 else {
                throw NSError(
                    domain: "CourierDelivery",
                    code: 2,
                    userInfo: [NSLocalizedDescriptionKey: "–ü—Ä–µ–≤—ã—à–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫. –ó–∞–ø—Ä–æ—Å–∏—Ç–µ –Ω–æ–≤—ã–π –∫–æ–¥."]
                )
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è –∫–æ–¥–∞
            guard !delivery.isCodeExpired else {
                throw NSError(
                    domain: "CourierDelivery",
                    code: 3,
                    userInfo: [NSLocalizedDescriptionKey: "–ö–æ–¥ –∏—Å—Ç–µ–∫. –ó–∞–ø—Ä–æ—Å–∏—Ç–µ –Ω–æ–≤—ã–π –∫–æ–¥."]
                )
            }
            
            // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –ø–æ–ø—ã—Ç–æ–∫
            var updated = delivery.incrementAttempts()
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–¥ —á–µ—Ä–µ–∑ Kaspi API
            let isValid = try await kaspiService.confirmDelivery(
                orderId: delivery.orderId,
                trackingNumber: delivery.trackingNumber,
                smsCode: code
            )
            
            if isValid {
                // –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ–º –¥–æ—Å—Ç–∞–≤–∫—É
                updated = updated.confirm(by: Auth.auth().currentUser?.uid ?? "")
                try await updateDeliveryInFirestore(updated)
                
                // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞
                try await updateOrderStatus(orderId: delivery.orderId, status: .completed)
                
                // –î–æ–±–∞–≤–ª—è–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é
                try await addToHistory(
                    deliveryId: delivery.id,
                    action: .delivered,
                    details: "–î–æ—Å—Ç–∞–≤–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞ –∫–æ–¥–æ–º"
                )
                
                currentDelivery = nil
                enteredCode = ""
                successMessage = "‚úÖ –î–æ—Å—Ç–∞–≤–∫–∞ —É—Å–ø–µ—à–Ω–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞!"
                
                // –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–∫–∏
                loadDeliveries()
                
            } else {
                // –ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥
                try await updateDeliveryInFirestore(updated)
                
                if updated.remainingAttempts == 0 {
                    errorMessage = "–ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥. –ü–æ–ø—ã—Ç–∫–∏ –∏—Å—á–µ—Ä–ø–∞–Ω—ã. –ó–∞–ø—Ä–æ—Å–∏—Ç–µ –Ω–æ–≤—ã–π –∫–æ–¥."
                } else {
                    errorMessage = "–ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥. –û—Å—Ç–∞–ª–æ—Å—å –ø–æ–ø—ã—Ç–æ–∫: \(updated.remainingAttempts)"
                }
            }
            
        } catch {
            errorMessage = error.localizedDescription
        }
        
        isVerifyingCode = false
    }
    
    /// –û—Ç–º–µ—Ç–∏—Ç—å –¥–æ—Å—Ç–∞–≤–∫—É –∫–∞–∫ –Ω–µ—É–¥–∞—á–Ω—É—é
    func markDeliveryFailed(_ delivery: DeliveryConfirmation, reason: String) async {
        isLoading = true
        errorMessage = nil
        
        do {
            let updated = delivery.updatingStatus(.failed)
            try await updateDeliveryInFirestore(updated)
            
            // –î–æ–±–∞–≤–ª—è–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é
            try await addToHistory(
                deliveryId: delivery.id,
                action: .failed,
                details: reason
            )
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞
            try await updateOrderStatus(orderId: delivery.orderId, status: .pending)
            
            currentDelivery = nil
            successMessage = "–î–æ—Å—Ç–∞–≤–∫–∞ –æ—Ç–º–µ—á–µ–Ω–∞ –∫–∞–∫ –Ω–µ—É–¥–∞—á–Ω–∞—è"
            
        } catch {
            errorMessage = "–û—à–∏–±–∫–∞: \(error.localizedDescription)"
        }
        
        isLoading = false
    }
    
    // MARK: - Private Methods
    
    /// –û–±–Ω–æ–≤–∏—Ç—å –¥–æ—Å—Ç–∞–≤–∫—É –≤ Firestore
    private func updateDeliveryInFirestore(_ delivery: DeliveryConfirmation) async throws {
        try await db.collection("deliveries")
            .document(delivery.id)
            .setData(delivery.toDictionary(), merge: true)
    }
    
    /// –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞
    private func updateOrderStatus(orderId: String, status: OrderStatus) async throws {
        try await db.collection("orders")
            .document(orderId)
            .updateData([
                "status": status.rawValue,
                "updatedAt": FieldValue.serverTimestamp()
            ])
    }
    
    /// –î–æ–±–∞–≤–∏—Ç—å –∑–∞–ø–∏—Å—å –≤ –∏—Å—Ç–æ—Ä–∏—é
    private func addToHistory(
        deliveryId: String,
        action: DeliveryAction,
        details: String? = nil,
        location: GeoPoint? = nil
    ) async throws {
        
        let history = DeliveryHistory(
            id: UUID().uuidString,
            deliveryId: deliveryId,
            action: action,
            performedBy: Auth.auth().currentUser?.uid ?? "",
            performedByRole: "Courier",
            timestamp: Date(),
            details: details,
            location: location
        )
        
        try await db.collection("deliveryHistory")
            .document(history.id)
            .setData([
                "deliveryId": history.deliveryId,
                "action": history.action.rawValue,
                "performedBy": history.performedBy,
                "performedByRole": history.performedByRole,
                "timestamp": Timestamp(date: history.timestamp),
                "details": details ?? NSNull(),
                "location": location ?? NSNull()
            ])
    }
    
    /// –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ç–µ—Å—Ç–æ–≤—ã–π SMS –∫–æ–¥
    private func generateTestSMSCode() -> String {
        let digits = "0123456789"
        return String((0..<6).map { _ in digits.randomElement()! })
    }
    
    // MARK: - Utility Methods
    
    /// –û—á–∏—Å—Ç–∏—Ç—å –≤–≤–µ–¥–µ–Ω–Ω—ã–π –∫–æ–¥
    func clearEnteredCode() {
        enteredCode = ""
    }
    
    /// –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–æ–¥ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
    func formatCode(_ code: String) -> String {
        let cleaned = code.replacingOccurrences(of: "[^0-9]", with: "", options: .regularExpression)
        if cleaned.count >= 3 {
            let index3 = cleaned.index(cleaned.startIndex, offsetBy: 3)
            let firstPart = cleaned[..<index3]
            let secondPart = cleaned[index3...]
            return "\(firstPart)-\(secondPart)"
        }
        return cleaned
    }
}

// MARK: - Location Extension

extension CourierDeliveryViewModel {
    
    /// –ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â—É—é –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é
    func getCurrentLocation() async -> CLLocationCoordinate2D? {
        // TODO: Implement location services
        return nil
    }
}
